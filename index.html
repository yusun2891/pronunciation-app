<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pronunciation Practice</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800;900&display=swap" rel="stylesheet">
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    <style>
        :root {
            --duo-green: #58CC02;
            --duo-blue: #1CB0F6;
            --duo-yellow: #FFC800;
            --duo-red: #FF4B4B;
            --duo-gray: #AFAFAF;
            --duo-light-gray: #F7F7F7;
            --text-dark: #3C3C3C;
            --text-gray: #777777;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Nunito', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #F7F7F7 0%, #FFFFFF 100%);
            min-height: 100vh;
            color: var(--text-dark);
            overflow-x: hidden;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 24px;
        }

        /* iPad Í∞ÄÎ°ú ÏµúÏ†ÅÌôî */
        @media (min-width: 768px) and (orientation: landscape) {
            .container {
                max-width: 900px;
                padding: 40px;
            }
        }

        /* Ìó§Îçî */
        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .title {
            font-size: 42px;
            font-weight: 900;
            color: var(--duo-green);
            margin-bottom: 8px;
            letter-spacing: -1px;
        }

        .subtitle {
            font-size: 18px;
            color: var(--text-gray);
            font-weight: 600;
        }

        /* ÏßÑÌñâ ÌëúÏãú */
        .progress-container {
            background: white;
            border-radius: 16px;
            padding: 12px 16px;
            margin-bottom: 24px;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.04);
        }

        .progress-steps {
            display: flex;
            align-items: center;
            justify-content: space-between;
            max-width: 500px;
            margin: 0 auto;
        }

        .step {
            display: flex;
            flex-direction: column;
            align-items: center;
            flex: 1;
        }

        .step-circle {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 900;
            font-size: 18px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 3px solid transparent;
        }

        .step-circle.active {
            background: var(--duo-green);
            color: white;
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(88, 204, 2, 0.2);
        }

        .step-circle.completed {
            background: var(--duo-green);
            color: white;
        }

        .step-circle.inactive {
            background: var(--duo-light-gray);
            color: var(--duo-gray);
            border-color: #E5E5E5;
        }

        .step-label {
            margin-top: 6px;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        .step-label.active {
            color: var(--duo-green);
        }

        .step-label.completed {
            color: var(--duo-green);
        }

        .step-label.inactive {
            color: var(--duo-gray);
        }

        .progress-line {
            flex: 1;
            height: 3px;
            border-radius: 2px;
            margin: 0 8px;
            transition: all 0.3s;
            align-self: flex-start;
            margin-top: 18px;
        }

        .progress-line.completed {
            background: var(--duo-green);
        }

        .progress-line.inactive {
            background: #E5E5E5;
        }

        /* Ïª®ÌÖêÏ∏† Ïπ¥Îìú */
        .content-card {
            background: white;
            border-radius: 24px;
            padding: 48px 40px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            border: 2px solid #F0F0F0;
            animation: fadeIn 0.4s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @media (min-width: 768px) and (orientation: landscape) {
            .content-card {
                padding: 56px 64px;
            }
        }

        .hidden {
            display: none !important;
        }

        h2 {
            font-size: 32px;
            font-weight: 900;
            color: var(--text-dark);
            margin-bottom: 24px;
            text-align: center;
            letter-spacing: -0.5px;
        }

        p {
            color: var(--text-gray);
            line-height: 1.6;
            margin-bottom: 24px;
            font-size: 17px;
            text-align: center;
            font-weight: 600;
        }

        /* Spacing utilities */
        .mb-4 {
            margin-bottom: 16px;
        }

        .mb-6 {
            margin-bottom: 24px;
        }

        .mb-8 {
            margin-bottom: 32px;
        }

        .mt-4 {
            margin-top: 16px;
        }

        .mt-6 {
            margin-top: 24px;
        }

        .mt-8 {
            margin-top: 32px;
        }

        /* Î≤ÑÌäº - Duolingo Ïä§ÌÉÄÏùº */
        button {
            padding: 18px 40px;
            font-size: 18px;
            font-weight: 800;
            border: none;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: 'Nunito', sans-serif;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 0 rgba(0, 0, 0, 0.1);
            position: relative;
            top: 0;
        }

        button:active:not(:disabled) {
            top: 4px;
            box-shadow: 0 0 0 rgba(0, 0, 0, 0.1);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background: var(--duo-green);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: #4CAD02;
            transform: scale(1.02);
        }

        .btn-secondary {
            background: #E5E5E5;
            color: var(--text-dark);
        }

        .btn-secondary:hover {
            background: #D0D0D0;
        }

        .btn-success {
            background: var(--duo-green);
            color: white;
        }

        .btn-success:hover:not(:disabled) {
            background: #4CAD02;
        }

        .btn-danger {
            background: var(--duo-red);
            color: white;
        }

        .btn-danger:hover:not(:disabled) {
            background: #E63939;
        }

        .btn-warning {
            background: var(--duo-yellow);
            color: var(--text-dark);
        }

        .btn-warning:hover:not(:disabled) {
            background: #F59E0B;
        }

        .btn-gray {
            background: var(--text-gray);
            color: white;
        }

        .btn-gray:hover {
            background: #666666;
        }

        .btn-small {
            padding: 10px 16px;
            font-size: 13px;
            font-weight: 700;
        }

        /* ÌîåÎ†âÏä§ Î†àÏù¥ÏïÑÏõÉ */
        .flex {
            display: flex;
        }

        .gap-4 {
            gap: 16px;
        }

        .flex-1 {
            flex: 1;
        }

        /* ÌÖçÏä§Ìä∏ ÏòÅÏó≠ */
        textarea {
            width: 100%;
            padding: 20px;
            font-size: 18px;
            line-height: 1.8;
            color: var(--text-dark);
            background: #F7F9FC;
            border: 3px solid #E5E7EB;
            border-radius: 16px;
            resize: none;
            font-family: 'Nunito', sans-serif;
            font-weight: 600;
            transition: all 0.2s;
            margin-bottom: 24px;
        }

        textarea:focus {
            outline: none;
            border-color: var(--duo-blue);
            background: white;
        }

        /* ÏûÖÎ†• ÌïÑÎìú */
        input[type="text"],
        input[type="number"] {
            padding: 16px 20px;
            font-size: 16px;
            border: 3px solid #E5E7EB;
            border-radius: 12px;
            font-family: 'Nunito', sans-serif;
            font-weight: 600;
            transition: all 0.2s;
            margin-bottom: 16px;
            width: 100%;
        }

        input:focus {
            outline: none;
            border-color: var(--duo-blue);
        }

        /* ÎÖπÏùå ÏÉÅÌÉú */
        .recording-status {
            display: inline-flex;
            align-items: center;
            gap: 12px;
            background: var(--duo-yellow);
            padding: 20px 32px;
            border-radius: 100px;
            border: 4px solid #FFA500;
            box-shadow: 0 8px 0 #FFA500;
        }

        .recording-dot {
            width: 16px;
            height: 16px;
            background: var(--duo-red);
            border-radius: 50%;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.3);
                opacity: 0.7;
            }
        }

        .recording-text {
            font-size: 20px;
            font-weight: 900;
            color: var(--text-dark);
        }

        /* ÏóêÎü¨ Î∞ïÏä§ */
        .error-box {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 16px 20px;
            background: #FEE2E2;
            border: 3px solid var(--duo-red);
            border-radius: 16px;
            margin-bottom: 20px;
        }

        .error-text {
            font-size: 16px;
            font-weight: 800;
            color: var(--duo-red);
        }

        /* ÏßÑÌñâ Î∞î (Î¨∏Ïû•Î≥Ñ) */
        .sentence-progress-container {
            background: #E5E5E5;
            height: 12px;
            border-radius: 100px;
            overflow: hidden;
            margin-bottom: 24px;
        }

        .sentence-progress-bar {
            background: linear-gradient(90deg, var(--duo-green), #4CAD02);
            height: 100%;
            transition: width 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            border-radius: 100px;
        }

        /* ÌòÑÏû¨ Î¨∏Ïû• Ïπ¥Îìú */
        .current-sentence-card {
            background: linear-gradient(135deg, #EEF2FF 0%, #E0E7FF 100%);
            border: 4px solid var(--duo-blue);
            border-radius: 20px;
            padding: 32px;
            margin-bottom: 32px;
            box-shadow: 0 8px 0 rgba(28, 176, 246, 0.2);
        }

        .sentence-label {
            font-size: 14px;
            font-weight: 900;
            color: var(--duo-blue);
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .sentence-text {
            font-size: 24px;
            line-height: 1.6;
            color: var(--text-dark);
            font-weight: 700;
        }

        /* Í≤∞Í≥º Ïπ¥Îìú */
        .result-card {
            background: white;
            border-radius: 20px;
            padding: 24px;
            margin-bottom: 16px;
            border: 3px solid #E5E5E5;
            transition: all 0.2s;
        }

        .result-card:hover {
            border-color: var(--duo-green);
            box-shadow: 0 4px 12px rgba(88, 204, 2, 0.15);
        }

        .result-card.green {
            border-color: var(--duo-green);
            background: linear-gradient(135deg, #F0FDF4 0%, #DCFCE7 100%);
        }

        .result-card.yellow {
            border-color: var(--duo-yellow);
            background: linear-gradient(135deg, #FFFBEB 0%, #FEF3C7 100%);
        }

        .result-card.red {
            border-color: var(--duo-red);
            background: linear-gradient(135deg, #FEF2F2 0%, #FEE2E2 100%);
        }

        /* Ï†êÏàò ÌëúÏãú */
        .score-circle {
            position: relative;
            width: 240px;
            height: 240px;
            flex-shrink: 0;
        }

        .score-value {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
        }

        /* Ïï†ÎãàÎ©îÏù¥ÏÖò */
        .animate-fadeIn {
            animation: fadeIn 0.4s ease-out;
        }

        /* Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú */
        .image-upload-label {
            display: inline-block;
            padding: 18px 40px;
            background: var(--duo-blue);
            color: white;
            border-radius: 16px;
            cursor: pointer;
            font-weight: 800;
            font-size: 18px;
            transition: all 0.2s;
            box-shadow: 0 4px 0 rgba(28, 176, 246, 0.3);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .image-upload-label:hover {
            background: #1698D1;
            transform: scale(1.02);
        }

        .image-upload-label:active {
            transform: translateY(4px);
            box-shadow: 0 0 0 rgba(28, 176, 246, 0.3);
        }

        /* ÏùåÏÑ± ÏÑ†ÌÉù */
        select {
            padding: 16px 20px;
            font-size: 16px;
            border: 3px solid #E5E7EB;
            border-radius: 12px;
            font-family: 'Nunito', sans-serif;
            font-weight: 700;
            background: white;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 16px;
            width: 100%;
        }

        select:focus {
            outline: none;
            border-color: var(--duo-blue);
        }

        /* ÌÜ†Í∏Ä Ïä§ÏúÑÏπò */
        .toggle-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            margin-bottom: 20px;
        }

        .toggle-label {
            font-size: 14px;
            font-weight: 700;
            color: var(--text-dark);
        }

        .toggle-switch {
            position: relative;
            width: 56px;
            height: 28px;
            background: #E5E5E5;
            border-radius: 100px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .toggle-switch.active {
            background: var(--duo-green);
        }

        .toggle-knob {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 22px;
            height: 22px;
            background: white;
            border-radius: 50%;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .toggle-switch.active .toggle-knob {
            left: 31px;
        }

        /* Î†àÏù¥Î∏î */
        label {
            display: block;
            font-size: 15px;
            font-weight: 700;
            color: var(--text-dark);
            margin-bottom: 8px;
        }

        /* Î∞òÏùëÌòï */
        @media (max-width: 768px) {
            .title {
                font-size: 32px;
            }

            h2 {
                font-size: 24px;
            }

            button {
                padding: 16px 28px;
                font-size: 16px;
            }

            .content-card {
                padding: 32px 24px;
            }
        }
        
        /* üé§ Re-record Î™®Îã¨ */
        .rerecord-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }
        
        .rerecord-modal.active {
            display: flex;
        }
        
        .rerecord-content {
            background: white;
            border-radius: 20px;
            padding: 32px;
            max-width: 600px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: modalSlideIn 0.3s ease-out;
        }
        
        @keyframes modalSlideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .rerecord-header {
            font-size: 24px;
            font-weight: 900;
            color: var(--text-dark);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .rerecord-sentence {
            background: #F3F4F6;
            border-left: 4px solid var(--duo-blue);
            padding: 20px;
            border-radius: 12px;
            font-size: 18px;
            line-height: 1.8;
            color: var(--text-dark);
            margin-bottom: 24px;
        }
        
        .rerecord-status {
            text-align: center;
            padding: 20px;
            font-size: 16px;
            font-weight: 600;
            color: var(--text-gray);
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .rerecord-buttons {
            display: flex;
            gap: 12px;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1 class="title">Pronunciation Practice</h1>
            <p class="subtitle">Listen, record, and improve your English pronunciation</p>
        </div>
        <!-- Progress Steps -->
        <div class="progress-container">
            <div class="progress-steps">
                <div class="step">
                    <div id="step1-circle" class="step-circle active">1</div>
                    <span id="step1-label" class="step-label active">Setup</span>
                </div>
                <div id="progress1" class="progress-line inactive"></div>
                
                <div class="step">
                    <div id="step2-circle" class="step-circle inactive">2</div>
                    <span id="step2-label" class="step-label inactive">Listen</span>
                </div>
                <div id="progress2" class="progress-line inactive"></div>
                
                <div class="step">
                    <div id="step3-circle" class="step-circle inactive">3</div>
                    <span id="step3-label" class="step-label inactive">Record</span>
                </div>
                <div id="progress3" class="progress-line inactive"></div>
                
                <div class="step">
                    <div id="step4-circle" class="step-circle inactive">4</div>
                    <span id="step4-label" class="step-label inactive">Results</span>
                </div>
            </div>
        </div>

        <!-- Step 1: Enter Text -->
        <div id="step1-content" class="content-card animate-fadeIn">
            <h2>Step 1: Setup & Enter Text</h2>
            
            <!-- Google Cloud API Key -->
            <div class="settings-panel" style="margin-bottom: 24px;">
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                    <label style="margin: 0; font-weight: bold; font-size: 16px;">
                        üîë Google Cloud API Key
                        <a href="https://console.cloud.google.com/apis/credentials" target="_blank" style="font-size: 12px; color: #3B82F6; margin-left: 8px;">(Get free key)</a>
                    </label>
                    <span id="key-saved-indicator" style="color: #10B981; font-size: 12px; font-weight: 600; display: none;">
                        ‚úì Saved
                    </span>
                </div>
                <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                    <input 
                        type="password" 
                        id="google-api-key" 
                        placeholder="Enter once - saved automatically (required for all features)"
                        style="flex: 1; padding: 12px; border: 2px solid #BFDBFE; border-radius: 8px; font-family: monospace;"
                    />
                    <button id="test-api-btn" class="btn-secondary" style="padding: 12px 24px; white-space: nowrap;">
                        Test API
                    </button>
                </div>
                <div id="api-test-result" style="display: none; padding: 12px; border-radius: 8px; margin-bottom: 16px;"></div>
            </div>
            
            <div id="step1-error" class="error-box hidden mb-6">
                <span id="step1-error-text" class="error-text">Please enter at least 10 characters of text.</span>
            </div>
            
            <!-- Image Upload Section -->
            <div style="margin-bottom: 32px;">
                <!-- OCR Mode Toggle -->
                <div class="toggle-container">
                    <span class="toggle-label">üåê Browser</span>
                    <div class="toggle-switch active" id="ocr-toggle">
                        <div class="toggle-knob"></div>
                    </div>
                    <span class="toggle-label">‚òÅÔ∏è Cloud</span>
                    <input type="hidden" id="ocr-mode-value" value="cloud">
                </div>
                
                <div id="drop-zone" style="border: 3px dashed #E5E7EB; border-radius: 16px; padding: 32px; text-align: center; background: #FAFAFA; cursor: pointer; transition: all 0.3s; margin-bottom: 20px;">
                    <div style="font-size: 56px; margin-bottom: 12px;">üì∏</div>
                    <div style="font-size: 18px; font-weight: 800; color: var(--text-dark); margin-bottom: 8px;">
                        Upload Images
                    </div>
                    <div style="font-size: 15px; color: var(--text-gray); font-weight: 600;">
                        Click or drag & drop
                    </div>
                    <input type="file" id="image-upload" accept="image/*" multiple style="display: none;">
                </div>
                
                <div style="text-align: center;">
                    <span id="processing-status" style="color: var(--duo-blue); font-weight: 700; font-size: 15px; display: none;">
                        ‚è≥ Processing...
                    </span>
                    <span id="image-name" style="color: var(--text-gray); font-size: 14px; font-weight: 600;"></span>
                </div>
                
                <!-- Multiple Images Preview Container -->
                <div id="images-container" style="display: none; margin-top: 12px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <span style="font-weight: 600; color: #4B5563;">Uploaded Images:</span>
                        <button id="clear-all-images-btn" style="background: #EF4444; color: white; border: none; padding: 4px 12px; border-radius: 6px; font-size: 12px; cursor: pointer; font-weight: 600;">Clear All</button>
                    </div>
                    <div id="image-previews" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 12px;">
                        <!-- Image cards will be inserted here -->
                    </div>
                </div>
            </div>
            
            <div style="text-align: center; margin-bottom: 16px; color: #6B7280; font-weight: 600;">
                - OR -
            </div>
            
            <textarea
                id="reading-text"
                rows="10"
                placeholder="Enter your text here..."
            ></textarea>
            
            <!-- Past Texts Section -->
            <div id="past-texts-section" style="margin-top: 20px; padding: 16px; background: #F9FAFB; border: 2px solid #E5E7EB; border-radius: 12px; display: none;">
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                    <h3 style="margin: 0; font-size: 16px; font-weight: 800; color: var(--text-dark);">üìù Past Texts</h3>
                    <button id="toggle-past-texts" style="background: none; border: none; color: var(--duo-blue); font-size: 13px; font-weight: 700; cursor: pointer; padding: 4px 8px;">
                        Hide
                    </button>
                </div>
                <div id="past-texts-list" style="max-height: 200px; overflow-y: auto;">
                    <!-- Past texts will be loaded here -->
                </div>
            </div>
            
            <div class="mt-6">
                <button id="confirm-text-btn" class="btn-primary" style="width: 100%;">
                    Continue to Listen ‚Üí
                </button>
            </div>
        </div>

        <!-- Step 2: Listen -->
        <div id="step2-content" class="hidden animate-fadeIn">
            <div class="content-card">
                <h2 style="margin-bottom: 16px;">Step 2: Listen to the Text</h2>
                
                <div style="text-align: right; margin-bottom: 16px;">
                    <button id="toggle-settings-btn" class="btn-secondary btn-small">
                        ‚öôÔ∏è Settings
                    </button>
                </div>
                
                <div id="voice-settings" class="settings-panel hidden mb-6">
                    <div class="mb-4">
                        <label>Voice Selection (Google Cloud Neural Voices)</label>
                        <select id="voice-select">
                            <option value="en-US-Neural2-A">US Female (Neural2-A) - Warm</option>
                            <option value="en-US-Neural2-C">US Female (Neural2-C) - Professional</option>
                            <option value="en-US-Neural2-E">US Female (Neural2-E) - Young</option>
                            <option value="en-US-Neural2-F">US Female (Neural2-F) - Clear</option>
                            <option value="en-US-Neural2-D">US Male (Neural2-D) - Deep</option>
                            <option value="en-US-Neural2-I" selected>US Male (Neural2-I) - Natural</option>
                            <option value="en-US-Neural2-J">US Male (Neural2-J) - Energetic</option>
                            <option value="en-GB-Neural2-A">UK Female (Neural2-A) - British</option>
                            <option value="en-GB-Neural2-B">UK Male (Neural2-B) - British</option>
                            <option value="en-GB-Neural2-C">UK Female (Neural2-C) - British Elegant</option>
                            <option value="en-AU-Neural2-A">AU Female (Neural2-A) - Australian</option>
                            <option value="en-AU-Neural2-B">AU Male (Neural2-B) - Australian</option>
                        </select>
                    </div>
                    
                    <div>
                        <label>Speech Rate: <span id="rate-display">1.0</span>x</label>
                        <div class="range-label">
                            <span class="range-text">Slow</span>
                            <input type="range" id="speech-rate" class="range-slider" min="0.5" max="1.5" step="0.1" value="1.0"/>
                            <span class="range-text">Fast</span>
                        </div>
                    </div>
                </div>
                
                <div class="text-box mb-6">
                    <div id="display-text" class="text-content" style="line-height: 2;"></div>
                </div>
                
                <div class="flex gap-4 mt-6">
                    <button id="play-btn" class="btn-success flex-1">‚ñ∂ Play</button>
                    <button id="pause-btn" class="btn-warning flex-1 hidden">‚è∏ Pause</button>
                    <button id="resume-btn" class="btn-success flex-1 hidden">‚ñ∂ Resume</button>
                    <button id="start-recording-btn" class="btn-primary flex-1">Start Recording ‚Üí</button>
                </div>
            </div>
        </div>

        <!-- Step 3: Record -->
        <div id="step3-content" class="hidden animate-fadeIn">
            <div class="content-card">
                <h2>Step 3: Record Sentence by Sentence</h2>
                <p>Click "Start Recording" for the first sentence. Then just click "Stop & Next" to continue!</p>
                
                <!-- Progress Indicator -->
                <div style="background: #F3F4F6; padding: 12px; border-radius: 8px; margin-bottom: 16px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <span style="font-weight: 600; color: #374151;">Progress:</span>
                        <span id="sentence-progress" style="font-weight: 600; color: #7C3AED;">Sentence 1 of 1</span>
                    </div>
                    <div style="background: #E5E7EB; height: 8px; border-radius: 4px; overflow: hidden;">
                        <div id="sentence-progress-bar" style="background: linear-gradient(to right, #7C3AED, #A78BFA); height: 100%; width: 0%; transition: width 0.3s;"></div>
                    </div>
                </div>
                
                <!-- Current Sentence Display -->
                <div style="background: #EEF2FF; border: 2px solid #7C3AED; border-radius: 12px; padding: 20px; margin-bottom: 16px;">
                    <div style="font-size: 13px; font-weight: 600; color: #6366F1; margin-bottom: 8px;">CURRENT SENTENCE:</div>
                    <div id="current-recording-sentence" style="font-size: 18px; line-height: 1.8; color: #1F2937;"></div>
                </div>
                
                <!-- Recording Status (Center) -->
                <div style="text-align: center; padding: 40px 20px; margin-bottom: 20px;">
                    <div id="recording-status" class="recording-status hidden">
                        <div class="recording-dot"></div>
                        <span class="recording-text">üé§ Recording...</span>
                    </div>
                </div>
                
                <!-- Hidden transcription div for Google Cloud results -->
                <div id="transcription" style="display: none;"></div>
                
                <div class="flex gap-4">
                    <button id="start-mic-btn" class="btn-danger flex-1">üé§ Start Recording</button>
                    <button id="stop-mic-btn" class="btn-gray flex-1 hidden">‚èπ Stop & Next</button>
                    <button id="evaluate-btn" class="btn-success flex-1 hidden">Get Accurate Score ‚Üí</button>
                </div>
                
                <!-- Completed Sentences List -->
            </div>
        </div>

        <!-- Step 4: Results -->
        <div id="step4-content" class="content-card hidden animate-fadeIn">
            <h2 style="color: var(--text-dark); margin-bottom: 32px; font-size: 28px; font-weight: 900;">Results</h2>
            
            <!-- Ï†êÏàò + ÌÜµÍ≥Ñ (Ï¢åÏö∞ Î∞∞Ïπò) -->
            <div style="display: flex; align-items: center; gap: 32px; margin-bottom: 40px; justify-content: center; flex-wrap: wrap;">
                <!-- ÏôºÏ™Ω: Ï†êÏàò Ïõê -->
                <div class="score-circle" style="flex-shrink: 0;">
                    <svg style="transform: rotate(-90deg); width: 100%; height: 100%;">
                        <circle cx="120" cy="120" r="100" stroke="#E5E7EB" stroke-width="16" fill="none" />
                        <circle id="progress-circle" cx="120" cy="120" r="100" stroke="var(--duo-green)" stroke-width="16" fill="none" 
                                stroke-dasharray="628.3" stroke-dashoffset="628.3" 
                                style="transition: stroke-dashoffset 1.5s ease-out;" 
                                stroke-linecap="round" />
                    </svg>
                    <div class="score-value">
                        <div id="accuracy-score" style="font-size: 56px; font-weight: 900; color: var(--duo-green); line-height: 1;">0%</div>
                    </div>
                </div>
                
                <!-- Ïò§Î•∏Ï™Ω: ÌÜµÍ≥Ñ -->
                <div style="display: flex; flex-direction: column; gap: 16px;">
                    <div style="background: white; border: 3px solid var(--duo-blue); border-radius: 12px; padding: 16px 28px; min-width: 160px;">
                        <div style="font-size: 12px; font-weight: 800; color: var(--duo-blue); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">Total Words</div>
                        <div id="total-words" style="font-size: 40px; font-weight: 900; color: var(--text-dark); line-height: 1;">0</div>
                    </div>
                    <div style="background: white; border: 3px solid var(--duo-green); border-radius: 12px; padding: 16px 28px; min-width: 160px;">
                        <div style="font-size: 12px; font-weight: 800; color: var(--duo-green); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">Correct</div>
                        <div id="matched-words" style="font-size: 40px; font-weight: 900; color: var(--text-dark); line-height: 1;">0</div>
                    </div>
                </div>
            </div>

            <!-- Î¨∏Ïû•Î≥Ñ Î∂ÑÏÑù -->
            <div style="margin-bottom: 32px;">
                <h3 style="font-size: 18px; font-weight: 800; color: var(--text-dark); margin-bottom: 16px;">üìù Your Pronunciation</h3>
                <div id="word-analysis"></div>
            </div>

            <!-- Î≤ÑÌäº -->
            <div style="text-align: center; display: flex; flex-direction: column; gap: 12px; align-items: center;">
                <button id="save-result-btn" class="btn-success" style="width: 100%; max-width: 400px; font-size: 17px; padding: 16px;">
                    üíæ Save This Result
                </button>
                <button id="reset-btn" class="btn-primary" style="width: 100%; max-width: 400px; font-size: 17px; padding: 16px;">
                    üîÑ Start New Practice
                </button>
                <button id="view-history-btn" class="btn-gray" style="width: 100%; max-width: 400px; font-size: 15px; padding: 12px;">
                    üìä View History
                </button>
            </div>
        </div>

        <!-- Step 5: History -->
        <div id="step5-content" class="content-card hidden animate-fadeIn">
            <h2 style="color: var(--text-dark); margin-bottom: 24px; font-size: 28px; font-weight: 900;">üìä Practice History</h2>
            
            <!-- Filter Controls -->
            <div style="margin-bottom: 20px; display: flex; gap: 12px; flex-wrap: wrap;">
                <select id="history-filter" style="padding: 10px 16px; border: 2px solid #E5E7EB; border-radius: 8px; font-weight: 600; font-size: 14px;">
                    <option value="all">All Results</option>
                    <option value="recent">Last 7 Days</option>
                    <option value="high">High Scores (80%+)</option>
                    <option value="low">Need Practice (<80%)</option>
                </select>
                <button id="refresh-history-btn" class="btn-gray" style="padding: 10px 20px;">
                    üîÑ Refresh
                </button>
            </div>
            
            <!-- History List -->
            <div id="history-list" style="margin-bottom: 24px;">
                <!-- Results will be loaded here -->
            </div>
            
            <!-- Back Button -->
            <div style="text-align: center;">
                <button id="back-from-history-btn" class="btn-primary" style="width: 100%; max-width: 400px;">
                    ‚Üê Back to Practice
                </button>
            </div>
        </div>

        <!-- Tips -->
        <div class="tips-card">
        </div>
    </div>

    <!-- üé§ Re-record Modal -->
    <div id="rerecord-modal" class="rerecord-modal">
        <div class="rerecord-content">
            <div class="rerecord-header">
                <span>üé§</span>
                <span id="rerecord-title">Re-record Sentence</span>
            </div>
            
            <div class="rerecord-sentence" id="rerecord-sentence-text">
                <!-- Sentence will be displayed here -->
            </div>
            
            <div class="rerecord-status" id="rerecord-status">
                Ready to record
            </div>
            
            <div class="rerecord-buttons">
                <button id="rerecord-start-btn" class="btn-success" style="flex: 1;">
                    üé§ Start Recording
                </button>
                <button id="rerecord-stop-btn" class="btn-danger" style="flex: 1; display: none;">
                    ‚èπ Stop & Evaluate
                </button>
                <button id="rerecord-cancel-btn" class="btn-gray" style="padding: 14px 24px;">
                    ‚úï Cancel
                </button>
            </div>
        </div>
    </div>

    <script>
        // Check browser support
        if (!('speechSynthesis' in window) || !('webkitSpeechRecognition' in window || 'SpeechRecognition' in window)) {
            alert('Your browser does not support speech features. Please use Chrome, Edge, or Safari.');
        }

        // Global variables
        let currentStep = 1;
        let readingText = '';
        let selectedVoice = 'en-US-Neural2-I';
        let speechRate = 1.0;
        let isPlaying = false;
        let isPaused = false;
        let transcription = '';
        let mediaRecorder = null;
        let audioChunks = [];
        let currentAudio = null;
        let currentSentences = [];
        let currentSentenceIndex = 0;
        let isPlaybackStopped = false;
        let recognition = null;
        let isRealTimeMode = true;
        let uploadedImages = []; // Store multiple images with their extracted text
        let recordedAudioBlob = null; // Store recorded audio for Google Cloud evaluation
        let realtimeTranscription = ''; // Store real-time transcription
        let recordingTimer = null; // Timer for 60-second recording limit
        let recordingStartTime = null; // Track recording start time
        
        // Sentence-by-sentence recording
        let recordingSentences = []; // Split sentences for recording
        let currentRecordingSentenceIndex = 0; // Current sentence being recorded
        let sentenceRecordings = []; // Array to store each sentence's recording
        let sentenceTranscriptions = []; // Array to store each sentence's transcription
        let microphoneStream = null; // Store microphone stream for reuse

        // ========================================
        // üíæ IndexedDB for Data Persistence
        // ========================================
        
        const DB_NAME = 'PronunciationPracticeDB';
        const DB_VERSION = 1;
        let db = null;
        
        // Initialize IndexedDB
        async function initDB() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                
                request.onerror = () => {
                    console.error('Failed to open database');
                    reject(request.error);
                };
                
                request.onsuccess = () => {
                    db = request.result;
                    console.log('‚úÖ Database initialized');
                    resolve(db);
                };
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    
                    // Text History Store
                    if (!db.objectStoreNames.contains('textHistory')) {
                        const textStore = db.createObjectStore('textHistory', { keyPath: 'id' });
                        textStore.createIndex('createdAt', 'createdAt', { unique: false });
                        textStore.createIndex('usedCount', 'usedCount', { unique: false });
                        console.log('Created textHistory store');
                    }
                    
                    // Practice Results Store
                    if (!db.objectStoreNames.contains('practiceResults')) {
                        const resultsStore = db.createObjectStore('practiceResults', { keyPath: 'id' });
                        resultsStore.createIndex('practiceDate', 'practiceDate', { unique: false });
                        resultsStore.createIndex('totalScore', 'totalScore', { unique: false });
                        resultsStore.createIndex('textId', 'textId', { unique: false });
                        console.log('Created practiceResults store');
                    }
                };
            });
        }
        
        // Save text to history
        async function saveTextHistory(text, source = 'manual') {
            if (!text || text.trim().length === 0) return null;
            
            const textId = 'text_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            const textData = {
                id: textId,
                text: text.trim(),
                source: source, // 'manual' or 'ocr'
                createdAt: new Date().toISOString(),
                usedCount: 1,
                lastUsedAt: new Date().toISOString()
            };
            
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['textHistory'], 'readwrite');
                const store = transaction.objectStore('textHistory');
                const request = store.add(textData);
                
                request.onsuccess = () => {
                    console.log('‚úÖ Text saved to history:', textId);
                    resolve(textData);
                };
                
                request.onerror = () => {
                    console.error('Failed to save text:', request.error);
                    reject(request.error);
                };
            });
        }
        
        // Update text usage count
        async function updateTextUsage(textId) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['textHistory'], 'readwrite');
                const store = transaction.objectStore('textHistory');
                const request = store.get(textId);
                
                request.onsuccess = () => {
                    const data = request.result;
                    if (data) {
                        data.usedCount++;
                        data.lastUsedAt = new Date().toISOString();
                        store.put(data);
                        resolve(data);
                    }
                };
                
                request.onerror = () => reject(request.error);
            });
        }
        
        // Get recent texts
        async function getRecentTexts(limit = 10) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['textHistory'], 'readonly');
                const store = transaction.objectStore('textHistory');
                const index = store.index('createdAt');
                const request = index.openCursor(null, 'prev'); // Descending order
                
                const results = [];
                
                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor && results.length < limit) {
                        results.push(cursor.value);
                        cursor.continue();
                    } else {
                        resolve(results);
                    }
                };
                
                request.onerror = () => reject(request.error);
            });
        }
        
        // Save practice result
        async function savePracticeResult(resultData) {
            const resultId = 'result_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            const data = {
                id: resultId,
                ...resultData,
                practiceDate: new Date().toISOString()
            };
            
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['practiceResults'], 'readwrite');
                const store = transaction.objectStore('practiceResults');
                const request = store.add(data);
                
                request.onsuccess = () => {
                    console.log('‚úÖ Practice result saved:', resultId);
                    resolve(data);
                };
                
                request.onerror = () => {
                    console.error('Failed to save result:', request.error);
                    reject(request.error);
                };
            });
        }
        
        // Get all practice results
        async function getAllResults(limit = 50) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['practiceResults'], 'readonly');
                const store = transaction.objectStore('practiceResults');
                const index = store.index('practiceDate');
                const request = index.openCursor(null, 'prev'); // Descending order
                
                const results = [];
                
                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor && results.length < limit) {
                        results.push(cursor.value);
                        cursor.continue();
                    } else {
                        resolve(results);
                    }
                };
                
                request.onerror = () => reject(request.error);
            });
        }
        
        // Delete practice result
        async function deleteResult(resultId) {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['practiceResults'], 'readwrite');
                const store = transaction.objectStore('practiceResults');
                const request = store.delete(resultId);
                
                request.onsuccess = () => {
                    console.log('‚úÖ Result deleted:', resultId);
                    resolve();
                };
                
                request.onerror = () => reject(request.error);
            });
        }
        
        // Delete text from history
        async function deleteText(textId) {
            console.log('üóëÔ∏è deleteText called with ID:', textId);
            return new Promise((resolve, reject) => {
                if (!db) {
                    console.error('‚ùå Database not available');
                    reject(new Error('Database not initialized'));
                    return;
                }
                
                try {
                    const transaction = db.transaction(['textHistory'], 'readwrite');
                    const store = transaction.objectStore('textHistory');
                    const request = store.delete(textId);
                    
                    request.onsuccess = () => {
                        console.log('‚úÖ Text deleted from DB:', textId);
                        resolve();
                    };
                    
                    request.onerror = () => {
                        console.error('‚ùå Delete request error:', request.error);
                        reject(request.error);
                    };
                    
                    transaction.onerror = () => {
                        console.error('‚ùå Transaction error:', transaction.error);
                        reject(transaction.error);
                    };
                } catch (error) {
                    console.error('‚ùå Exception in deleteText:', error);
                    reject(error);
                }
            });
        }
        
        // Initialize database on page load
        let dbInitialized = false;
        
        async function initializeApp() {
            try {
                console.log('üöÄ Initializing app...');
                
                // 1. Initialize database
                await initDB();
                dbInitialized = true;
                console.log('‚úÖ Database initialized');
                
                // 2. Load Google settings
                loadGoogleSettings();
                console.log('‚úÖ Google settings loaded');
                
                // 3. Load past texts
                await loadPastTexts();
                console.log('‚úÖ Past texts loaded');
                
            } catch (err) {
                console.error('‚ùå App initialization failed:', err);
                alert('‚ö†Ô∏è Failed to initialize app. Some features may not work.');
            }
        }
        
        // Start initialization immediately
        initializeApp();

        // Load Google Cloud settings from localStorage
        function loadGoogleSettings() {
            const savedKey = localStorage.getItem('googleApiKey');
            if (savedKey) {
                document.getElementById('google-api-key').value = savedKey;
                document.getElementById('key-saved-indicator').style.display = 'inline';
            }
        }

        // Save Google Cloud settings to localStorage
        function saveGoogleSettings() {
            const key = document.getElementById('google-api-key').value;
            if (key) {
                localStorage.setItem('googleApiKey', key);
                // Show saved indicator
                const indicator = document.getElementById('key-saved-indicator');
                indicator.style.display = 'inline';
                indicator.textContent = '‚úì Saved';
                
                // Briefly show "Saved!" then return to "‚úì Saved"
                setTimeout(() => {
                    indicator.textContent = '‚úì Saved!';
                    setTimeout(() => {
                        indicator.textContent = '‚úì Saved';
                    }, 1000);
                }, 100);
            }
        }

        loadGoogleSettings();

        // Test API key functionality
        document.getElementById('test-api-btn').addEventListener('click', async function() {
            const apiKey = document.getElementById('google-api-key').value.trim();
            const resultDiv = document.getElementById('api-test-result');
            
            if (!apiKey) {
                resultDiv.style.display = 'block';
                resultDiv.style.background = '#FEE2E2';
                resultDiv.style.border = '2px solid #FCA5A5';
                resultDiv.innerHTML = '<p style="margin: 0; color: #991B1B; font-weight: 600;">‚ùå Please enter an API key first</p>';
                return;
            }
            
            // Show loading
            resultDiv.style.display = 'block';
            resultDiv.style.background = '#EFF6FF';
            resultDiv.style.border = '2px solid #BFDBFE';
            resultDiv.innerHTML = '<p style="margin: 0; color: #1E40AF; font-weight: 600;">‚è≥ Testing APIs... (this may take a few seconds)</p>';
            
            const results = {
                vision: { status: false, error: '' },
                tts: { status: false, error: '' },
                stt: { status: false, error: '' }
            };
            
            // Test Vision API
            try {
                const visionResponse = await fetch(
                    `https://vision.googleapis.com/v1/images:annotate?key=${apiKey}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            requests: [{
                                image: { content: 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==' },
                                features: [{ type: 'TEXT_DETECTION' }]
                            }]
                        })
                    }
                );
                
                if (visionResponse.ok) {
                    results.vision.status = true;
                } else {
                    const errorData = await visionResponse.json().catch(() => ({}));
                    results.vision.error = errorData.error?.message || `HTTP ${visionResponse.status}`;
                }
            } catch (e) {
                results.vision.error = e.message;
            }
            
            // Test TTS API
            try {
                const ttsResponse = await fetch(
                    `https://texttospeech.googleapis.com/v1/text:synthesize?key=${apiKey}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            input: { text: 'test' },
                            voice: { languageCode: 'en-US', name: 'en-US-Neural2-A' },
                            audioConfig: { audioEncoding: 'MP3' }
                        })
                    }
                );
                
                if (ttsResponse.ok) {
                    results.tts.status = true;
                } else {
                    const errorData = await ttsResponse.json().catch(() => ({}));
                    results.tts.error = errorData.error?.message || `HTTP ${ttsResponse.status}`;
                }
            } catch (e) {
                results.tts.error = e.message;
            }
            
            // Test STT API
            try {
                const sttResponse = await fetch(
                    `https://speech.googleapis.com/v1/speech:recognize?key=${apiKey}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            config: { encoding: 'LINEAR16', sampleRateHertz: 16000, languageCode: 'en-US' },
                            audio: { content: 'test' }
                        })
                    }
                );
                
                if (sttResponse.ok) {
                    results.stt.status = true;
                } else {
                    const errorData = await sttResponse.json().catch(() => ({}));
                    results.stt.error = errorData.error?.message || `HTTP ${sttResponse.status}`;
                }
            } catch (e) {
                results.stt.error = e.message;
            }
            
            // Display results
            const allWorking = results.vision.status && results.tts.status && results.stt.status;
            
            let html = '<div style="font-size: 13px;">';
            html += `<p style="margin: 0 0 12px 0; font-weight: 700; font-size: 14px;">${allWorking ? '‚úÖ All APIs Working!' : '‚ö†Ô∏è Some APIs Have Issues'}</p>`;
            
            // Vision API
            html += `<div style="margin-bottom: 8px; padding: 8px; background: ${results.vision.status ? '#D1FAE5' : '#FEE2E2'}; border-radius: 6px;">`;
            html += `<p style="margin: 0; font-weight: 600;">Vision API: ${results.vision.status ? '‚úÖ Working' : '‚ùå Failed'}</p>`;
            if (!results.vision.status) {
                html += `<p style="margin: 4px 0 0 0; font-size: 11px; color: #991B1B;">Error: ${results.vision.error}</p>`;
            }
            html += `</div>`;
            
            // TTS API
            html += `<div style="margin-bottom: 8px; padding: 8px; background: ${results.tts.status ? '#D1FAE5' : '#FEE2E2'}; border-radius: 6px;">`;
            html += `<p style="margin: 0; font-weight: 600;">Text-to-Speech: ${results.tts.status ? '‚úÖ Working' : '‚ùå Failed'}</p>`;
            if (!results.tts.status) {
                html += `<p style="margin: 4px 0 0 0; font-size: 11px; color: #991B1B;">Error: ${results.tts.error}</p>`;
            }
            html += `</div>`;
            
            // STT API
            html += `<div style="margin-bottom: 8px; padding: 8px; background: ${results.stt.status ? '#D1FAE5' : '#FEE2E2'}; border-radius: 6px;">`;
            html += `<p style="margin: 0; font-weight: 600;">Speech-to-Text: ${results.stt.status ? '‚úÖ Working' : '‚ùå Failed'}</p>`;
            if (!results.stt.status) {
                html += `<p style="margin: 4px 0 0 0; font-size: 11px; color: #991B1B;">Error: ${results.stt.error}</p>`;
            }
            html += `</div>`;
            
            if (!allWorking) {
                html += '<div style="margin-top: 12px; padding: 12px; background: #FEF3C7; border-radius: 6px;">';
                html += '<p style="margin: 0 0 8px 0; font-weight: 700; color: #92400E;">üîß How to Fix:</p>';
                html += '<ol style="margin: 0; padding-left: 20px; font-size: 12px; color: #92400E;">';
                html += '<li style="margin-bottom: 4px;"><strong>Enable APIs:</strong> Make sure all 3 APIs are enabled in <a href="https://console.cloud.google.com/apis/library" target="_blank" style="color: #3B82F6;">Google Cloud Console</a></li>';
                html += '<li style="margin-bottom: 4px;"><strong>Check API Key:</strong> Go to <a href="https://console.cloud.google.com/apis/credentials" target="_blank" style="color: #3B82F6;">Credentials</a> ‚Üí Click your API key</li>';
                html += '<li style="margin-bottom: 4px;"><strong>Remove Restrictions:</strong> Under "API restrictions", select "Don\'t restrict key" (or add the 3 APIs)</li>';
                html += '<li style="margin-bottom: 4px;"><strong>HTTP Referrer:</strong> Under "Application restrictions", select "None"</li>';
                html += '<li><strong>Billing:</strong> Some APIs require billing enabled (free tier available)</li>';
                html += '</ol>';
                html += '</div>';
            }
            html += '</div>';
            
            resultDiv.style.background = allWorking ? '#D1FAE5' : '#FEF3C7';
            resultDiv.style.border = allWorking ? '2px solid #6EE7B7' : '2px solid #FCD34D';
            resultDiv.innerHTML = html;
        });

        // Update progress
        async function updateProgress(step) {
            console.log('updateProgress called with step:', step);
            currentStep = step;
            
            try {
                for (let i = 1; i <= 4; i++) {
                    const circle = document.getElementById(`step${i}-circle`);
                    const label = document.getElementById(`step${i}-label`);
                    
                    if (!circle || !label) {
                        console.error(`Missing element: step${i}-circle or step${i}-label`);
                        continue;
                    }
                    
                    circle.className = 'step-circle';
                    label.className = 'step-label';
                    
                    if (i < step) {
                        circle.classList.add('completed');
                        circle.textContent = '‚úì';
                        label.classList.add('active');
                    } else if (i === step) {
                        circle.classList.add('active');
                        circle.textContent = i;
                        label.classList.add('active');
                    } else {
                        circle.classList.add('inactive');
                        circle.textContent = i;
                        label.classList.add('inactive');
                    }
                }
                
                for (let i = 1; i <= 3; i++) {
                    const progress = document.getElementById(`progress${i}`);
                    if (!progress) {
                        console.error(`Missing element: progress${i}`);
                        continue;
                    }
                    progress.className = 'progress-line';
                    if (i < step) {
                        progress.classList.add('completed');
                    } else {
                        progress.classList.add('inactive');
                    }
                }
                
                const step1Content = document.getElementById('step1-content');
                const step2Content = document.getElementById('step2-content');
                const step3Content = document.getElementById('step3-content');
                const step4Content = document.getElementById('step4-content');
                
                if (!step1Content || !step2Content || !step3Content || !step4Content) {
                    console.error('Missing step content elements!');
                    return;
                }
                
                step1Content.classList.toggle('hidden', step !== 1);
                step2Content.classList.toggle('hidden', step !== 2);
                step3Content.classList.toggle('hidden', step !== 3);
                step4Content.classList.toggle('hidden', step !== 4);
                
                // When entering Step 3, prepare sentence-by-sentence recording
                if (step === 3) {
                    await prepareSentenceRecording();
                }
                
                console.log('updateProgress completed successfully. Current visible step:', step);
                
            } catch (error) {
                console.error('Error in updateProgress:', error);
            }
        }
        
        // üéØ Ïä§ÎßàÌä∏ Î¨∏Ïû• Î∂ÑÌï† (Î™®Îì† Ïó£ÏßÄ ÏºÄÏù¥Ïä§ Í≥†Î†§)
        function smartSentenceSplit(text) {
            if (!text || text.trim().length === 0) {
                return [];
            }
            
            console.log('üìù Starting smart sentence split...');
            console.log('Original text:', text);
            
            // 1Îã®Í≥Ñ: Î≥¥Ìò∏Ìï¥Ïïº Ìï† Ìå®ÌÑ¥Îì§ÏùÑ ÏûÑÏãú ÎßàÏª§Î°ú ÍµêÏ≤¥
            let protected = text;
            const protectedItems = [];
            let markerIndex = 0;
            
            // 1-1. ÏïΩÏñ¥ Î≥¥Ìò∏
            const abbreviations = [
                'Mr.', 'Mrs.', 'Ms.', 'Miss.', 'Dr.', 'Prof.', 'Sr.', 'Jr.',
                'St.', 'Ave.', 'Rd.', 'Blvd.', 'Apt.', 'Dept.', 'Bldg.',
                'U.S.', 'U.K.', 'U.N.', 'E.U.', 'U.S.A.',
                'a.m.', 'p.m.', 'A.M.', 'P.M.',
                'etc.', 'vs.', 'Inc.', 'Ltd.', 'Co.', 'Corp.',
                'vol.', 'ch.', 'no.', 'No.', 'pp.', 'ed.', 'et al.'
            ];
            
            abbreviations.forEach(abbr => {
                const regex = new RegExp(abbr.replace(/\./g, '\\.'), 'gi');
                protected = protected.replace(regex, (match) => {
                    const marker = `__MARKER${markerIndex}__`;
                    protectedItems[markerIndex] = match;
                    markerIndex++;
                    return marker;
                });
            });
            
            // 1-2. Ïà´Ïûê Ìå®ÌÑ¥ Î≥¥Ìò∏
            const numberPatterns = [
                /\$\d+(?:,\d{3})*(?:\.\d+)?/g,
                /\d+(?:,\d{3})*(?:\.\d+)?%?/g,
                /\d+:\d+(?::\d+)?(?:\s*[ap]\.?m\.?)?/gi
            ];
            
            numberPatterns.forEach(pattern => {
                protected = protected.replace(pattern, (match) => {
                    const marker = `__MARKER${markerIndex}__`;
                    protectedItems[markerIndex] = match;
                    markerIndex++;
                    return marker;
                });
            });
            
            // 1-3. Ïù¥Î©îÏùº Î≥¥Ìò∏
            protected = protected.replace(/[\w.-]+@[\w.-]+\.\w+/g, (match) => {
                const marker = `__MARKER${markerIndex}__`;
                protectedItems[markerIndex] = match;
                markerIndex++;
                return marker;
            });
            
            // 1-4. URL Î≥¥Ìò∏
            const urlPatterns = [
                /https?:\/\/[^\s]+/g,
                /www\.[^\s]+/g,
                /[a-zA-Z0-9-]+\.[a-zA-Z]{2,}(?:\/[^\s]*)?/g
            ];
            
            urlPatterns.forEach(pattern => {
                protected = protected.replace(pattern, (match) => {
                    const marker = `__MARKER${markerIndex}__`;
                    protectedItems[markerIndex] = match;
                    markerIndex++;
                    return marker;
                });
            });
            
            // 1-5. ÏÉùÎûµ Î∂ÄÌò∏ Î≥¥Ìò∏
            protected = protected.replace(/\.{3,}/g, (match) => {
                const marker = `__MARKER${markerIndex}__`;
                protectedItems[markerIndex] = match;
                markerIndex++;
                return marker;
            });
            
            console.log('After protection:', protected);
            
            // 2Îã®Í≥Ñ: Í∞ÑÎã®ÌïòÍ≥† Ï†ïÌôïÌïú Î¨∏Ïû• Î∂ÑÌï†
            const sentences = [];
            let current = '';
            let inQuote = false;
            let quoteDepth = 0;
            
            for (let i = 0; i < protected.length; i++) {
                const char = protected[i];
                const nextChar = protected[i + 1] || '';
                const next2Char = protected[i + 2] || '';
                
                current += char;
                
                // Îî∞Ïò¥Ìëú Ï∂îÏ†Å (Ïó¥Í∏∞/Îã´Í∏∞)
                if (char === '"' || char === '\u201C' || char === '\u201D') {
                    if (!inQuote) {
                        inQuote = true;
                        quoteDepth++;
                    } else {
                        quoteDepth--;
                        if (quoteDepth === 0) {
                            inQuote = false;
                        }
                    }
                }
                
                // Î¨∏Ïû• ÎÅù Í∞êÏßÄ (Îî∞Ïò¥Ìëú Î∞ñÏóêÏÑúÎßå)
                if (!inQuote && (char === '.' || char === '!' || char === '?')) {
                    // Îã§ÏùåÏù¥ Í≥µÎ∞±, ÎåÄÎ¨∏Ïûê, Îî∞Ïò¥Ìëú, ÎòêÎäî ÎÅùÏù¥Î©¥ Î¨∏Ïû• ÏôÑÎ£å
                    const isEnd = (
                        nextChar === '' ||
                        nextChar === '\n' ||
                        nextChar === '\r' ||
                        (nextChar === ' ' && (next2Char === '' || /[A-Z"\u201C]/.test(next2Char))) ||
                        /[A-Z"\u201C]/.test(nextChar)
                    );
                    
                    // ÎßàÏª§ Ï≤¥ÌÅ¨ (ÏïΩÏñ¥Í∞Ä ÏïÑÎãåÏßÄ)
                    const endsWithMarker = /__MARKER\d+__$/.test(current.trim());
                    
                    if (isEnd && !endsWithMarker) {
                        const trimmed = current.trim();
                        if (trimmed.length > 0) {
                            sentences.push(trimmed);
                            current = '';
                        }
                    }
                }
            }
            
            // ÎßàÏßÄÎßâ ÎÇ®ÏùÄ ÌÖçÏä§Ìä∏
            if (current.trim().length > 0) {
                sentences.push(current.trim());
            }
            
            // 3Îã®Í≥Ñ: ÎåÄÌôî ÌÉúÍ∑∏ Î≥ëÌï© (says X, asked Y Îì±Ïù¥ ÌòºÏûê ÏûàÎäî Í≤ΩÏö∞)
            const merged = [];
            for (let i = 0; i < sentences.length; i++) {
                const sentence = sentences[i];
                const nextSentence = sentences[i + 1] || '';
                
                // Îã§Ïùå Î¨∏Ïû•Ïù¥ ÏßßÍ≥† ÎåÄÌôî ÌÉúÍ∑∏Î°ú ÏãúÏûëÌïòÎ©¥ Î≥ëÌï©
                const dialogueTagPattern = /^(said|says|asked|asks|replied|replies|shouted|shouts|whispered|whispers|exclaimed|exclaims|answered|answers|continued|continues|added|adds|thought|thinks|wondered|wonders|cried|cries|yelled|yells|muttered|mutters|murmured|murmurs|declared|declares|announced|announces|stated|states|explained|explains|remarked|remarks)\s+\w+/i;
                
                if (nextSentence && nextSentence.length < 50 && dialogueTagPattern.test(nextSentence.trim())) {
                    // Î≥ëÌï©
                    merged.push(sentence + ' ' + nextSentence);
                    i++; // Îã§Ïùå Î¨∏Ïû• Í±¥ÎÑàÎõ∞Í∏∞
                } else {
                    merged.push(sentence);
                }
            }
            
            // 4Îã®Í≥Ñ: Î≥¥Ìò∏Îêú Ìï≠Î™© Î≥µÏõê
            const restored = merged.map(sentence => {
                let result = sentence;
                protectedItems.forEach((item, index) => {
                    if (item !== undefined) {
                        const marker = `__MARKER${index}__`;
                        result = result.replace(new RegExp(marker, 'g'), item);
                    }
                });
                return result;
            });
            
            // 5Îã®Í≥Ñ: Ï†ïÎ¶¨
            const cleaned = restored
                .filter(s => s.trim().length > 0)
                .map(s => s.trim());
            
            console.log('‚úÖ Final sentences:', cleaned);
            console.log('Total:', cleaned.length, 'sentences');
            
            return cleaned.length > 0 ? cleaned : [text];
        }
        
        // Prepare sentences for recording
        async function prepareSentenceRecording() {
            console.log('Preparing sentence recording...');
            console.log('Reading text:', readingText);
            
            // üéØ Ïä§ÎßàÌä∏ Î¨∏Ïû• Î∂ÑÌï† (ÏïΩÏñ¥ Î∞è ÎåÄÌôîÎ¨∏ Í≥†Î†§)
            recordingSentences = smartSentenceSplit(readingText);
            recordingSentences = recordingSentences.map(s => s.trim()).filter(s => s.length > 0);
            
            console.log('Split into sentences:', recordingSentences);
            console.log('Total sentences:', recordingSentences.length);
            
            // Reset recording state
            currentRecordingSentenceIndex = 0;
            sentenceRecordings = [];
            sentenceTranscriptions = [];
            
            // Request microphone access ONCE for all sentences (only if not already granted)
            if (!microphoneStream) {
                try {
                    console.log('üé§ Requesting microphone access for the first time...');
                    microphoneStream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            channelCount: 1,
                            echoCancellation: true,
                            noiseSuppression: true
                        }
                    });
                    console.log('‚úÖ Microphone access granted - will be reused for all sentences');
                } catch (error) {
                    console.error('Microphone access error:', error);
                    alert('‚ö†Ô∏è Microphone access denied. Please allow microphone access to record.\n\nError: ' + error.message);
                    updateProgress(2); // Go back to Step 2
                    return;
                }
            } else {
                console.log('‚úÖ Reusing existing microphone stream (no permission prompt)');
            }
            
            // Update UI
            updateSentenceDisplay();
            const completedContainer = document.getElementById('completed-sentences-container');
            if (completedContainer) completedContainer.style.display = 'none';
            document.getElementById('evaluate-btn').classList.add('hidden');
            document.getElementById('transcription').style.display = 'none';
            document.getElementById('start-mic-btn').classList.remove('hidden'); // üëÜ Ï≤´ Î¨∏Ïû•ÏùÄ Start Î≤ÑÌäº ÌëúÏãú
            document.getElementById('stop-mic-btn').classList.add('hidden');
            document.getElementById('recording-status').classList.add('hidden');
            
            console.log('Sentence recording prepared - waiting for user to start');
        }
        
        // Update current sentence display and progress
        function updateSentenceDisplay() {
            console.log('Updating sentence display for index:', currentRecordingSentenceIndex);
            
            const currentSentence = recordingSentences[currentRecordingSentenceIndex];
            const totalSentences = recordingSentences.length;
            const progress = ((currentRecordingSentenceIndex + 1) / totalSentences) * 100;
            const isLastSentence = (currentRecordingSentenceIndex === totalSentences - 1);
            
            console.log('Current sentence:', currentSentence);
            console.log('Progress:', progress + '%');
            console.log('Is last sentence:', isLastSentence);
            
            // Update current sentence
            const sentenceElement = document.getElementById('current-recording-sentence');
            if (sentenceElement) {
                sentenceElement.innerHTML = highlightWordsInSentence(currentSentence);
            } else {
                console.error('Element not found: current-recording-sentence');
            }
            
            // Update progress
            const progressElement = document.getElementById('sentence-progress');
            if (progressElement) {
                progressElement.textContent = `Sentence ${currentRecordingSentenceIndex + 1} of ${totalSentences}`;
            } else {
                console.error('Element not found: sentence-progress');
            }
            
            const progressBarElement = document.getElementById('sentence-progress-bar');
            if (progressBarElement) {
                progressBarElement.style.width = `${progress}%`;
            } else {
                console.error('Element not found: sentence-progress-bar');
            }
            
            // üéØ ÎßàÏßÄÎßâ Î¨∏Ïû•Ïùº Îïå Î≤ÑÌäº ÌÖçÏä§Ìä∏ Î≥ÄÍ≤Ω
            const stopBtn = document.getElementById('stop-mic-btn');
            if (stopBtn) {
                if (isLastSentence) {
                    stopBtn.innerHTML = '‚èπ Stop & Get Accurate Score';
                    console.log('‚úÖ Last sentence - button text changed to "Stop & Get Accurate Score"');
                } else {
                    stopBtn.innerHTML = '‚èπ Stop & Next';
                    console.log('‚û°Ô∏è Not last sentence - button text is "Stop & Next"');
                }
            }
        }
        
        // Display sentence (no highlighting)
        function highlightWordsInSentence(sentence) {
            // Just return the sentence as-is, no span wrapping
            return sentence;
        }

        // Step 1
        document.getElementById('confirm-text-btn').addEventListener('click', function(e) {
            console.log('Confirm button clicked');
            e.preventDefault(); // Prevent any default behavior
            
            const textArea = document.getElementById('reading-text');
            if (!textArea) {
                console.error('Textarea not found!');
                alert('Error: Text area not found. Please refresh the page.');
                return;
            }
            
            readingText = textArea.value.trim();
            console.log('Reading text:', readingText);
            console.log('Text length:', readingText.length);
            
            if (readingText.length < 10) {
                const errorBox = document.getElementById('step1-error');
                const errorText = document.getElementById('step1-error-text');
                errorBox.classList.remove('hidden');
                errorText.textContent = `Please enter at least 10 characters. Current: ${readingText.length} characters.`;
                console.log('Text too short, showing error');
                
                // Scroll to error
                errorBox.scrollIntoView({ behavior: 'smooth', block: 'center' });
                return;
            }
            
            document.getElementById('step1-error').classList.add('hidden');
            
            // üíæ Save text to history
            if (db && dbInitialized) {
                saveTextHistory(readingText, 'manual')
                    .then(() => {
                        console.log('‚úÖ Text saved to history');
                        loadPastTexts(); // Refresh past texts list
                    })
                    .catch(err => {
                        console.warn('‚ö†Ô∏è Failed to save text history:', err);
                    });
            } else {
                console.warn('‚ö†Ô∏è Database not initialized yet');
            }
            
            try {
                // Split text into sentences and display with highlighting capability
                const sentences = readingText.match(/[^.!?]+[.!?]+/g) || [readingText];
                console.log('Sentences found:', sentences.length);
                
                let displayHTML = '';
                sentences.forEach((sentence, index) => {
                    displayHTML += `<span class="sentence" data-index="${index}" style="transition: background-color 0.3s;">${sentence.trim()} </span>`;
                });
                
                const displayElement = document.getElementById('display-text');
                if (!displayElement) {
                    console.error('Display text element not found!');
                    alert('Error: Display element not found. Please refresh the page.');
                    return;
                }
                
                displayElement.innerHTML = displayHTML;
                console.log('Display text updated successfully');
                
                // Progress to Step 2
                console.log('Calling updateProgress(2)');
                updateProgress(2);
                console.log('Progress updated to Step 2');
                
            } catch (error) {
                console.error('Error in confirm-text-btn:', error);
                alert('Error processing text: ' + error.message + '\n\nPlease try again or refresh the page.');
            }
        });

        // OCR Mode Toggle
        const ocrToggle = document.getElementById('ocr-toggle');
        const ocrModeValue = document.getElementById('ocr-mode-value');
        
        ocrToggle.addEventListener('click', () => {
            ocrToggle.classList.toggle('active');
            if (ocrToggle.classList.contains('active')) {
                ocrModeValue.value = 'cloud';
            } else {
                ocrModeValue.value = 'browser';
            }
        });

        // Image upload handling
        const dropZone = document.getElementById('drop-zone');
        const imageUpload = document.getElementById('image-upload');
        
        // Click to upload
        dropZone.addEventListener('click', () => {
            imageUpload.click();
        });
        
        // Drag and drop
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.style.borderColor = '#8B5CF6';
            dropZone.style.background = '#EDE9FE';
        });
        
        dropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dropZone.style.borderColor = '#C7D2FE';
            dropZone.style.background = '#F5F3FF';
        });
        
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.style.borderColor = '#C7D2FE';
            dropZone.style.background = '#F5F3FF';
            
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
                processImage(file);
            } else {
                alert('Please drop an image file');
            }
        });
        
        imageUpload.addEventListener('change', async function(e) {
            const files = Array.from(e.target.files);
            if (files.length > 0) {
                for (const file of files) {
                    await processImage(file);
                }
            }
            // Reset input so same file can be selected again
            e.target.value = '';
        });
        
        // Clear all images button
        document.getElementById('clear-all-images-btn').addEventListener('click', function() {
            uploadedImages = [];
            document.getElementById('image-previews').innerHTML = '';
            document.getElementById('images-container').style.display = 'none';
            updateCombinedText();
        });
        
        // Remove individual image
        function removeImage(imageId) {
            uploadedImages = uploadedImages.filter(img => img.id !== imageId);
            updateImagePreviews();
            updateCombinedText();
            
            if (uploadedImages.length === 0) {
                document.getElementById('images-container').style.display = 'none';
            }
        }
        
        // Make removeImage accessible globally for onclick
        window.removeImage = removeImage;
        
        // Update combined text from all images
        function updateCombinedText() {
            const combinedText = uploadedImages
                .map(img => img.text)
                .filter(text => text && text.trim())
                .join('\n\n');
            
            document.getElementById('reading-text').value = combinedText;
        }
        
        // Update image previews display
        function updateImagePreviews() {
            const container = document.getElementById('image-previews');
            container.innerHTML = '';
            
            uploadedImages.forEach(imageData => {
                const card = document.createElement('div');
                card.style.cssText = 'position: relative; border: 2px solid #C7D2FE; border-radius: 8px; padding: 8px; background: #F5F3FF;';
                
                card.innerHTML = `
                    <button onclick="removeImage('${imageData.id}')" style="position: absolute; top: 4px; right: 4px; background: #EF4444; color: white; border: none; width: 24px; height: 24px; border-radius: 50%; cursor: pointer; font-size: 14px; font-weight: bold; display: flex; align-items: center; justify-content: center; z-index: 10;">√ó</button>
                    <img src="${imageData.dataUrl}" style="width: 100%; height: 120px; object-fit: cover; border-radius: 6px; margin-bottom: 4px;">
                    <div style="font-size: 11px; color: #6B7280; text-align: center; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${imageData.name}</div>
                    <div style="font-size: 10px; color: #059669; text-align: center; margin-top: 2px;">${imageData.wordCount} words</div>
                `;
                
                container.appendChild(card);
            });
        }
        
        async function processImage(file) {
            const ocrMode = document.getElementById('ocr-mode-value').value;
            
            const imageId = Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            
            if (ocrMode === 'browser') {
                await processImageWithTesseract(file, imageId);
            } else {
                await processImageWithCloud(file, imageId);
            }
        }
        
        // Browser OCR with Tesseract.js
        async function processImageWithTesseract(file, imageId) {
            // Show processing status
            document.getElementById('processing-status').style.display = 'inline';
            document.getElementById('processing-status').textContent = `‚è≥ Processing ${file.name}...`;
            document.getElementById('image-name').textContent = file.name;
            
            try {
                // Get image data URL
                const dataUrl = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
                
                // OCR with Tesseract.js - specify worker path explicitly
                const { createWorker } = Tesseract;
                const worker = await createWorker('eng', 1, {
                    workerPath: 'https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/worker.min.js',
                    langPath: 'https://cdn.jsdelivr.net/npm/tesseract.js-core@5/lang-data',
                    corePath: 'https://cdn.jsdelivr.net/npm/tesseract.js-core@5',
                    logger: info => {
                        if (info.status === 'recognizing text') {
                            const progress = Math.round(info.progress * 100);
                            document.getElementById('processing-status').textContent = `‚è≥ ${file.name}: ${progress}%`;
                        }
                    }
                });
                
                const result = await worker.recognize(file);
                await worker.terminate();
                
                let extractedText = result.data.text.trim();
                
                if (extractedText.length < 10) {
                    alert(`Could not extract enough text from ${file.name}. Please try a clearer image.`);
                    document.getElementById('processing-status').style.display = 'none';
                    return;
                }
                
                // Basic text cleaning
                extractedText = extractedText
                    .replace(/\s+/g, ' ')
                    .replace(/\s+([.,!?;:])/g, '$1')
                    .replace(/([.,!?;:])([A-Z])/g, '$1 $2')
                    .replace(/\n{3,}/g, '\n\n')
                    .replace(/^\s+/gm, '')
                    .trim();
                
                // Count words
                const wordCount = extractedText.split(/\s+/).length;
                
                // Add to uploaded images array
                uploadedImages.push({
                    id: imageId,
                    name: file.name,
                    dataUrl: dataUrl,
                    text: extractedText,
                    wordCount: wordCount
                });
                
                // Update UI
                document.getElementById('images-container').style.display = 'block';
                updateImagePreviews();
                updateCombinedText();
                
                document.getElementById('processing-status').textContent = '‚úÖ Done!';
                setTimeout(() => {
                    document.getElementById('processing-status').style.display = 'none';
                    document.getElementById('image-name').textContent = '';
                }, 2000);
                
            } catch (error) {
                console.error('Tesseract error:', error);
                
                // Check if it's a CORS/Worker error
                if (error.message && (error.message.includes('Worker') || error.message.includes('SecurityError'))) {
                    alert(`‚ö†Ô∏è Browser OCR requires local file execution.\n\n` +
                          `Please download this HTML file and open it locally, or use Cloud OCR mode instead.\n\n` +
                          `Error: ${error.message}`);
                } else {
                    alert(`Error processing ${file.name} with browser OCR. Please try again or use Cloud mode.\n\nError: ${error.message}`);
                }
                
                document.getElementById('processing-status').style.display = 'none';
                document.getElementById('image-name').textContent = '';
            }
        }
        
        // Cloud OCR with Google Vision API
        async function processImageWithCloud(file, imageId) {
            const apiKey = document.getElementById('google-api-key').value.trim();
            
            if (!apiKey) {
                alert('‚ö†Ô∏è Please enter your Google Cloud API key first (at the top of Step 1), then upload the image.');
                return;
            }
            
            // Show processing status
            document.getElementById('processing-status').style.display = 'inline';
            document.getElementById('processing-status').textContent = `‚è≥ Processing ${file.name}...`;
            document.getElementById('image-name').textContent = file.name;
            
            try {
                // Convert image to base64 and get data URL
                const base64Data = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result.split(',')[1]);
                    reader.onerror = () => reject(new Error('Failed to read file'));
                    reader.readAsDataURL(file);
                });
                
                const dataUrl = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
                
                // Call Google Cloud Vision API
                const response = await fetch(
                    `https://vision.googleapis.com/v1/images:annotate?key=${apiKey}`,
                    {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            requests: [
                                {
                                    image: {
                                        content: base64Data
                                    },
                                    features: [
                                        {
                                            type: 'TEXT_DETECTION'
                                        }
                                    ]
                                }
                            ]
                        })
                    }
                );
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    const errorMsg = errorData.error?.message || response.statusText;
                    throw new Error(`API Error (${response.status}): ${errorMsg}`);
                }
                
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error.message || 'Vision API error');
                }
                
                if (!data.responses || !data.responses[0]) {
                    throw new Error('No response from Vision API');
                }
                
                const result = data.responses[0];
                
                if (result.error) {
                    throw new Error(result.error.message || 'Vision API error');
                }
                
                if (!result.textAnnotations || result.textAnnotations.length === 0) {
                    alert(`Could not extract text from ${file.name}. Please try a clearer image.`);
                    document.getElementById('processing-status').style.display = 'none';
                    return;
                }
                
                // Get the full text
                let extractedText = result.textAnnotations[0].description.trim();
                
                if (extractedText.length < 10) {
                    alert(`Could not extract enough text from ${file.name}. Please try a clearer image.`);
                    document.getElementById('processing-status').style.display = 'none';
                    return;
                }
                
                // Basic text cleaning
                extractedText = extractedText
                    .replace(/\s+/g, ' ')
                    .replace(/\s+([.,!?;:])/g, '$1')
                    .replace(/([.,!?;:])([A-Z])/g, '$1 $2')
                    .replace(/\n{3,}/g, '\n\n')
                    .replace(/^\s+/gm, '')
                    .trim();
                
                // Count words
                const wordCount = extractedText.split(/\s+/).length;
                
                // Add to uploaded images array
                uploadedImages.push({
                    id: imageId,
                    name: file.name,
                    dataUrl: dataUrl,
                    text: extractedText,
                    wordCount: wordCount
                });
                
                // Update UI
                document.getElementById('images-container').style.display = 'block';
                updateImagePreviews();
                updateCombinedText();
                
                document.getElementById('processing-status').textContent = '‚úÖ Done!';
                setTimeout(() => {
                    document.getElementById('processing-status').style.display = 'none';
                    document.getElementById('image-name').textContent = '';
                }, 2000);
                
            } catch (error) {
                console.error('Error processing image:', error);
                
                let errorMessage = `‚ùå Error processing ${file.name}\n\n`;
                
                if (error.message.includes('Failed to fetch')) {
                    errorMessage += 'Network error or CORS issue.\n\nPossible solutions:\n';
                    errorMessage += '1. Check your internet connection\n';
                    errorMessage += '2. Verify your API key is correct\n';
                    errorMessage += '3. Make sure Vision API is enabled';
                } else if (error.message.includes('API_KEY_INVALID') || error.message.includes('400')) {
                    errorMessage += 'Invalid API key.\n\nPlease check:\n';
                    errorMessage += '1. API key is copied correctly\n';
                    errorMessage += '2. No extra spaces in the key\n';
                    errorMessage += '3. Vision API is enabled';
                } else if (error.message.includes('403')) {
                    errorMessage += 'Vision API is not enabled or quota exceeded.\n\n';
                    errorMessage += 'Enable it at: https://console.cloud.google.com/apis/library/vision.googleapis.com';
                } else if (error.message.includes('quota')) {
                    errorMessage += 'API quota exceeded.\n\n';
                    errorMessage += 'Check your usage at Google Cloud Console.';
                } else {
                    errorMessage += error.message;
                }
                
                alert(errorMessage);
                document.getElementById('processing-status').style.display = 'none';
                document.getElementById('image-name').textContent = '';
            }
        }

        // Voice settings
        document.getElementById('toggle-settings-btn').addEventListener('click', function() {
            document.getElementById('voice-settings').classList.toggle('hidden');
        });

        document.getElementById('voice-select').addEventListener('change', function() {
            selectedVoice = this.value;
        });

        document.getElementById('speech-rate').addEventListener('input', function() {
            speechRate = parseFloat(this.value);
            document.getElementById('rate-display').textContent = speechRate.toFixed(1);
        });

        // Audio controls with Google Cloud TTS
        document.getElementById('play-btn').addEventListener('click', playAudio);
        document.getElementById('pause-btn').addEventListener('click', pauseAudio);
        document.getElementById('resume-btn').addEventListener('click', resumeAudio);

        async function playAudio() {
            const apiKey = document.getElementById('google-api-key').value.trim();
            
            if (!apiKey) {
                alert('‚ö†Ô∏è Please enter your Google Cloud API key first in Step 1, then try again.');
                return;
            }
            
            saveGoogleSettings();
            
            // Stop any existing audio
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }
            
            // Split text into sentences
            currentSentences = readingText.match(/[^.!?]+[.!?]+/g) || [readingText];
            currentSentenceIndex = 0;
            isPlaybackStopped = false;
            
            // Remove all highlights
            document.querySelectorAll('.sentence').forEach(span => {
                span.style.backgroundColor = '';
                span.style.color = '';
                span.style.fontWeight = '';
            });
            
            // Update UI
            document.getElementById('play-btn').classList.add('hidden');
            document.getElementById('pause-btn').classList.remove('hidden');
            document.getElementById('start-recording-btn').disabled = true;
            isPlaying = true;
            
            // Start playing sentences
            await playNextSentence(apiKey);
        }

        async function playNextSentence(apiKey) {
            if (isPlaybackStopped || currentSentenceIndex >= currentSentences.length) {
                // All sentences played
                isPlaying = false;
                isPaused = false;
                resetAudioButtons();
                // Remove all highlights
                document.querySelectorAll('.sentence').forEach(span => {
                    span.style.backgroundColor = '';
                    span.style.color = '';
                    span.style.fontWeight = '';
                });
                return;
            }
            
            const sentence = currentSentences[currentSentenceIndex].trim();
            
            // Highlight current sentence
            document.querySelectorAll('.sentence').forEach((span, index) => {
                if (index === currentSentenceIndex) {
                    span.style.backgroundColor = '#FEF08A';
                    span.style.color = '#000';
                    span.style.fontWeight = 'bold';
                } else if (index < currentSentenceIndex) {
                    span.style.backgroundColor = '';
                    span.style.color = '#9CA3AF';
                    span.style.fontWeight = 'normal';
                } else {
                    span.style.backgroundColor = '';
                    span.style.color = '';
                    span.style.fontWeight = '';
                }
            });
            
            try {
                // Call Google Cloud TTS for this sentence
                const response = await fetch(
                    `https://texttospeech.googleapis.com/v1/text:synthesize?key=${apiKey}`,
                    {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            input: { text: sentence },
                            voice: {
                                languageCode: selectedVoice.substring(0, 5),
                                name: selectedVoice
                            },
                            audioConfig: {
                                audioEncoding: 'MP3',
                                speakingRate: speechRate
                            }
                        })
                    }
                );
                
                const data = await response.json();
                
                if (data.error) {
                    throw new Error(data.error.message || 'TTS API error');
                }
                
                // Convert base64 audio to playable format
                const audioContent = data.audioContent;
                const audioBlob = base64ToBlob(audioContent, 'audio/mp3');
                const audioUrl = URL.createObjectURL(audioBlob);
                
                currentAudio = new Audio(audioUrl);
                
                currentAudio.onended = function() {
                    URL.revokeObjectURL(audioUrl);
                    currentSentenceIndex++;
                    if (!isPlaybackStopped) {
                        playNextSentence(apiKey);
                    }
                };
                
                currentAudio.onerror = function() {
                    alert('Error playing audio');
                    resetAudioButtons();
                    URL.revokeObjectURL(audioUrl);
                };
                
                if (!isPlaybackStopped) {
                    await currentAudio.play();
                }
                
            } catch (error) {
                console.error('Google Cloud TTS error:', error);
                
                let errorMsg = 'Error: ' + error.message;
                if (error.message.includes('API key')) {
                    errorMsg = 'Invalid API key. Please check your Google Cloud API key.';
                } else if (error.message.includes('quota')) {
                    errorMsg = 'API quota exceeded. Check your Google Cloud console.';
                } else if (error.message.includes('not enabled')) {
                    errorMsg = 'Text-to-Speech API is not enabled. Enable it in Google Cloud Console: https://console.cloud.google.com/apis/library/texttospeech.googleapis.com';
                }
                
                alert(errorMsg);
                resetAudioButtons();
            }
        }

        function pauseAudio() {
            if (currentAudio) {
                currentAudio.pause();
                isPaused = true;
                document.getElementById('pause-btn').classList.add('hidden');
                document.getElementById('resume-btn').classList.remove('hidden');
                document.getElementById('start-recording-btn').disabled = false;
            }
        }

        function resumeAudio() {
            if (currentAudio && isPaused) {
                currentAudio.play();
                isPaused = false;
                document.getElementById('resume-btn').classList.add('hidden');
                document.getElementById('pause-btn').classList.remove('hidden');
                document.getElementById('start-recording-btn').disabled = true;
            }
        }

        function stopAudio() {
            isPlaybackStopped = true;
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }
            isPlaying = false;
            isPaused = false;
            
            // Remove all highlights
            document.querySelectorAll('.sentence').forEach(span => {
                span.style.backgroundColor = '';
                span.style.color = '';
                span.style.fontWeight = '';
            });
            
            resetAudioButtons();
        }

        function resetAudioButtons() {
            document.getElementById('play-btn').classList.remove('hidden');
            document.getElementById('pause-btn').classList.add('hidden');
            document.getElementById('resume-btn').classList.add('hidden');
            document.getElementById('start-recording-btn').disabled = false;
        }
        
        // Helper function to convert base64 to blob
        function base64ToBlob(base64, mimeType) {
            const byteCharacters = atob(base64);
            const byteNumbers = new Array(byteCharacters.length);
            for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
            }
            const byteArray = new Uint8Array(byteNumbers);
            return new Blob([byteArray], { type: mimeType });
        }

        // Navigation
        document.getElementById('start-recording-btn').addEventListener('click', function() {
            console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            console.log('‚ñ∂Ô∏è START RECORDING BUTTON (Step 2) CLICKED');
            console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            
            stopAudio();
            // Remove TTS highlights
            document.querySelectorAll('.sentence').forEach(span => {
                span.style.backgroundColor = '';
                span.style.color = '';
                span.style.fontWeight = '';
            });
            
            // Move to Step 3 (prepareSentenceRecording will be called automatically)
            console.log('Moving to Step 3...');
            updateProgress(3);
        });


        // Recording - Sentence by sentence
        document.getElementById('start-mic-btn').addEventListener('click', async function() {
            console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            console.log('üé§ START RECORDING BUTTON CLICKED');
            console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            
            try {
                await startSentenceRecording();
                console.log('‚úÖ Start recording completed successfully');
            } catch (err) {
                console.error('‚ùå ERROR in startSentenceRecording:', err);
                console.error('Error stack:', err.stack);
                alert('‚ö†Ô∏è Recording error: ' + err.message + '\n\nCheck console (F12) for details.');
                
                // Î≤ÑÌäº ÏÉÅÌÉú Î≥µÍµ¨
                document.getElementById('start-mic-btn').classList.remove('hidden');
                document.getElementById('stop-mic-btn').classList.add('hidden');
                document.getElementById('recording-status').classList.add('hidden');
            }
        });
        
        document.getElementById('stop-mic-btn').addEventListener('click', async function() {
            console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            console.log('‚èπ STOP BUTTON CLICKED');
            console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            
            try {
                const isLastSentence = (currentRecordingSentenceIndex === recordingSentences.length - 1);
                console.log('Current sentence index:', currentRecordingSentenceIndex);
                console.log('Total sentences:', recordingSentences.length);
                console.log('Is last sentence:', isLastSentence);
                
                await stopSentenceRecording();
                console.log('‚úÖ Stop recording completed successfully');
                
                // ÎßàÏßÄÎßâ Î¨∏Ïû•Ïù¥Î©¥ Î∞îÎ°ú ÌèâÍ∞Ä ÏãúÏûë
                if (isLastSentence) {
                    console.log('üöÄ Last sentence - auto-starting evaluation in 300ms...');
                    setTimeout(() => {
                        const evalBtn = document.getElementById('evaluate-btn');
                        if (evalBtn) {
                            console.log('Clicking evaluate button...');
                            evalBtn.click();
                        } else {
                            console.error('‚ùå Evaluate button not found!');
                            alert('Error: Evaluate button not found. Please refresh the page.');
                        }
                    }, 300);
                } else {
                    console.log('‚û°Ô∏è Not last sentence - next recording will auto-start');
                }
            } catch (error) {
                console.error('‚ùå ERROR in stop button handler:', error);
                console.error('Error stack:', error.stack);
                alert('‚ö†Ô∏è Error stopping recording: ' + error.message + '\n\nCheck console (F12) for details.');
                
                // Î≤ÑÌäº ÏÉÅÌÉú Î≥µÍµ¨
                document.getElementById('start-mic-btn').classList.remove('hidden');
                document.getElementById('stop-mic-btn').classList.add('hidden');
                document.getElementById('recording-status').classList.add('hidden');
            }
        });
        
        // Start recording current sentence
        async function startSentenceRecording() {
            console.log('Start recording clicked');
            console.log('Current sentence index:', currentRecordingSentenceIndex);
            console.log('Total sentences:', recordingSentences.length);
            console.log('Recording sentences:', recordingSentences);
            
            if (!recordingSentences || recordingSentences.length === 0) {
                alert('‚ö†Ô∏è No sentences found. Please go back and enter text first.');
                return;
            }
            
            if (currentRecordingSentenceIndex >= recordingSentences.length) {
                alert('‚ö†Ô∏è All sentences already recorded. Click "Get Accurate Score".');
                return;
            }
            
            if (!microphoneStream) {
                alert('‚ö†Ô∏è Microphone not available. Please go back and try again.');
                return;
            }
            
            // üîß Ïù¥Ï†Ñ mediaRecorderÍ∞Ä ÏïÑÏßÅ Ï†ïÎ¶¨ÎêòÏßÄ ÏïäÏïòÎã§Î©¥ Ï†ïÎ¶¨
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                console.log('‚ö†Ô∏è Previous mediaRecorder still active, stopping...');
                mediaRecorder.stop();
                await new Promise(resolve => setTimeout(resolve, 100)); // 100ms ÎåÄÍ∏∞
            }
            mediaRecorder = null; // ÌôïÏã§Ìûà Ï¥àÍ∏∞Ìôî
            
            try {
                // Check browser support
                if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
                    alert('Real-time speech recognition is not supported in this browser. Please use Chrome or Edge.');
                    return;
                }
                
                console.log('Using existing microphone stream (no permission prompt)');
                console.log('Creating new MediaRecorder...');
                
                // Start MediaRecorder with existing stream
                mediaRecorder = new MediaRecorder(microphoneStream, {
                    mimeType: 'audio/webm;codecs=opus'
                });
                
                console.log('‚úÖ MediaRecorder created successfully');
                
                audioChunks = [];
                
                // Error handler for MediaRecorder
                mediaRecorder.onerror = (event) => {
                    console.error('‚ùå MediaRecorder error:', event.error);
                    alert('‚ö†Ô∏è Recording error: ' + event.error.message);
                };
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                        console.log('Audio chunk received, size:', event.data.size);
                    }
                };
                
                // Create a promise that resolves when recording is saved
                window.currentRecordingPromise = new Promise((resolve, reject) => {
                    mediaRecorder.onstop = () => {
                        console.log('MediaRecorder onstop fired');
                        console.log('Audio chunks collected:', audioChunks.length);
                        
                        if (audioChunks.length === 0) {
                            console.error('‚ùå No audio chunks collected!');
                            reject(new Error('No audio data recorded'));
                            return;
                        }
                        
                        // Save this sentence's recording
                        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        console.log('Created blob, size:', audioBlob.size);
                        
                        if (audioBlob.size === 0) {
                            console.error('‚ùå Audio blob is empty!');
                            reject(new Error('Empty audio recording'));
                            return;
                        }
                        
                        sentenceRecordings[currentRecordingSentenceIndex] = audioBlob;
                        console.log('Saved to sentenceRecordings[' + currentRecordingSentenceIndex + ']');
                        
                        // Don't stop tracks - we'll reuse the stream
                        
                        // Resolve the promise
                        resolve(audioBlob);
                    };
                });
                
                mediaRecorder.start();
                console.log('‚úÖ MediaRecorder.start() called');
                
                // Wait a bit and verify it's recording
                setTimeout(() => {
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        console.log('‚úÖ MediaRecorder is actively recording');
                    } else {
                        console.error('‚ùå MediaRecorder failed to start recording. State:', mediaRecorder ? mediaRecorder.state : 'null');
                    }
                }, 100);
                
                // Start Real-time Speech Recognition
                const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition();
                
                recognition.continuous = true;
                recognition.interimResults = true;
                recognition.lang = 'en-US';
                
                let finalTranscript = '';
                
                recognition.onstart = function() {
                    console.log('Speech recognition started');
                    document.getElementById('start-mic-btn').classList.add('hidden');
                    document.getElementById('stop-mic-btn').classList.remove('hidden');
                    document.getElementById('recording-status').classList.remove('hidden');
                };
                
                recognition.onresult = function(event) {
                    let interimTranscript = '';
                    
                    for (let i = event.resultIndex; i < event.results.length; i++) {
                        const transcript = event.results[i][0].transcript;
                        if (event.results[i].isFinal) {
                            finalTranscript += transcript + ' ';
                        } else {
                            interimTranscript += transcript;
                        }
                    }
                    
                    const currentTranscript = finalTranscript + interimTranscript;
                    
                    // No highlighting - just save transcription
                    // (STT is only for saving, not for display)
                };
                
                recognition.onerror = function(event) {
                    console.error('Speech recognition error:', event.error);
                    let errorMsg = 'Speech recognition error: ';
                    if (event.error === 'no-speech') {
                        errorMsg += 'No speech detected. Please speak clearly.';
                    } else if (event.error === 'network') {
                        errorMsg += 'Network error. Please check your connection.';
                    } else {
                        errorMsg += event.error;
                    }
                    // Show error as alert instead of in transcription div
                    console.error(errorMsg);
                };
                
                recognition.onend = function() {
                    console.log('Speech recognition ended');
                    // Save transcription for this sentence
                    sentenceTranscriptions[currentRecordingSentenceIndex] = finalTranscript.trim();
                    console.log('Transcription saved:', finalTranscript.trim());
                };
                
                recognition.start();
                console.log('Speech recognition started');
                
            } catch (error) {
                console.error('Error starting recording:', error);
                alert('Error accessing microphone: ' + error.message + '\n\nPlease make sure you granted microphone permission.');
            }
        }
        
        // Highlight words in current sentence as user speaks
        function highlightSentenceWords(spokenText) {
            const spokenWords = spokenText.toLowerCase().split(/\s+/).filter(w => w.length > 0);
            const wordSpans = document.querySelectorAll('.sentence-word');
            
            // Í∞Å ÏõêÎ¨∏ Îã®Ïñ¥Ïóê ÎåÄÌï¥ ÎßêÌïú Îã®Ïñ¥ Ï§ëÏóêÏÑú Îß§Ïπ≠ Ï∞æÍ∏∞
            const matched = new Set(); // Ïù¥ÎØ∏ Îß§Ïπ≠Îêú spoken word Ïù∏Îç±Ïä§
            
            wordSpans.forEach((span, spanIndex) => {
                const originalWord = span.textContent.toLowerCase().replace(/[.,!?;:]/g, '');
                let foundMatch = false;
                
                // ÎßêÌïú Îã®Ïñ¥Îì§ Ï§ëÏóêÏÑú Îß§Ïπ≠ÎêòÎäî Í≤É Ï∞æÍ∏∞
                for (let i = 0; i < spokenWords.length; i++) {
                    if (matched.has(i)) continue; // Ïù¥ÎØ∏ Îß§Ïπ≠Îêú Îã®Ïñ¥Îäî Ïä§ÌÇµ
                    
                    const spokenWord = spokenWords[i].replace(/[.,!?;:]/g, '');
                    
                    // Ï†ïÌôïÌïú Îß§Ïπ≠ ÎòêÎäî Ïú†ÏÇ¨ Îß§Ïπ≠
                    if (originalWord === spokenWord || 
                        originalWord.includes(spokenWord) || 
                        spokenWord.includes(originalWord) ||
                        isSimilar(originalWord, spokenWord)) {
                        
                        // Îß§Ïπ≠ Î∞úÍ≤¨!
                        span.style.backgroundColor = '#D1FAE5';
                        span.style.color = '#065F46';
                        span.style.fontWeight = 'bold';
                        matched.add(i);
                        foundMatch = true;
                        break;
                    }
                }
                
                if (!foundMatch) {
                    // Îß§Ïπ≠ ÏïàÎê® - Í∏∞Î≥∏ Ïä§ÌÉÄÏùº
                    span.style.backgroundColor = '';
                    span.style.color = '';
                    span.style.fontWeight = '';
                }
            });
        }
        
        // Îã®Ïñ¥ Ïú†ÏÇ¨ÎèÑ Ï≤¥ÌÅ¨ (Í∞ÑÎã®Ìïú Î≤ÑÏ†Ñ)
        function isSimilar(word1, word2) {
            if (word1.length < 3 || word2.length < 3) return false;
            
            // Ï≤´ 2Í∏ÄÏûêÍ∞Ä Í∞ôÍ≥† Í∏∏Ïù¥Í∞Ä ÎπÑÏä∑ÌïòÎ©¥ Ïú†ÏÇ¨ÌïòÎã§Í≥† ÌåêÎã®
            if (word1.substring(0, 2) === word2.substring(0, 2)) {
                const lengthDiff = Math.abs(word1.length - word2.length);
                return lengthDiff <= 2;
            }
            
            return false;
        }
        
        // Stop recording and move to next sentence
        async function stopSentenceRecording() {
            console.log('Stop sentence recording called');
            console.log('Current sentence index:', currentRecordingSentenceIndex);
            console.log('MediaRecorder state:', mediaRecorder ? mediaRecorder.state : 'null');
            
            if (recognition) {
                recognition.stop();
                recognition = null;
                console.log('Speech recognition stopped');
            }
            
            // Stop mediaRecorder and wait for blob to be saved
            if (!mediaRecorder) {
                console.error('‚ùå MediaRecorder is null - recording was never started');
                alert('‚ö†Ô∏è Recording was not started. Click "Start Recording" button or wait for auto-start.');
                // Î≤ÑÌäº ÏÉÅÌÉú Î≥µÍµ¨
                document.getElementById('start-mic-btn').classList.remove('hidden');
                document.getElementById('stop-mic-btn').classList.add('hidden');
                document.getElementById('recording-status').classList.add('hidden');
                return;
            }
            
            if (mediaRecorder.state === 'inactive') {
                console.error('‚ùå MediaRecorder is inactive - no active recording');
                alert('‚ö†Ô∏è No active recording found. Please start recording first.');
                // Î≤ÑÌäº ÏÉÅÌÉú Î≥µÍµ¨
                document.getElementById('start-mic-btn').classList.remove('hidden');
                document.getElementById('stop-mic-btn').classList.add('hidden');
                document.getElementById('recording-status').classList.add('hidden');
                return;
            }
            
            console.log('‚úÖ Stopping media recorder (state: ' + mediaRecorder.state + ')');
            mediaRecorder.stop();
            
            // Wait for the recording to be saved
            try {
                const savedBlob = await window.currentRecordingPromise;
                console.log('Recording saved successfully, size:', savedBlob.size, 'bytes');
            } catch (error) {
                console.error('Error saving recording:', error);
                alert('‚ö†Ô∏è Recording failed to save. Please try recording this sentence again.');
                // Î≤ÑÌäº ÏÉÅÌÉú Î≥µÍµ¨
                document.getElementById('start-mic-btn').classList.remove('hidden');
                document.getElementById('stop-mic-btn').classList.add('hidden');
                document.getElementById('recording-status').classList.add('hidden');
                return;
            }
            
            // üîß mediaRecorder Ï†ïÎ¶¨
            mediaRecorder = null;
            console.log('MediaRecorder cleaned up');
            
            // Verify recording was saved
            const savedBlob = sentenceRecordings[currentRecordingSentenceIndex];
            if (savedBlob && savedBlob instanceof Blob && savedBlob.size > 0) {
                console.log(`‚úÖ Recording ${currentRecordingSentenceIndex + 1} verified: ${savedBlob.size} bytes`);
            } else {
                console.error(`‚ùå Recording ${currentRecordingSentenceIndex + 1} NOT saved properly!`, savedBlob);
                alert('‚ö†Ô∏è Recording was not saved properly. Please try recording this sentence again.');
                return;
            }
            
            // Add to completed list
            addCompletedSentence(currentRecordingSentenceIndex);
            
            // Move to next sentence
            currentRecordingSentenceIndex++;
            console.log('Moving to sentence index:', currentRecordingSentenceIndex);
            
            if (currentRecordingSentenceIndex < recordingSentences.length) {
                // More sentences to record - AUTO START NEXT RECORDING
                updateSentenceDisplay();
                
                // ÏûêÎèôÏúºÎ°ú Îã§Ïùå Î¨∏Ïû• ÎÖπÏùå ÏãúÏûë (ÏïΩÍ∞ÑÏùò ÎîúÎ†àÏù¥Î°ú ÏïàÏ†ïÌôî)
                console.log('üé§ Auto-starting next sentence recording in 300ms...');
                
                await new Promise(resolve => setTimeout(resolve, 300)); // 300ms ÎåÄÍ∏∞
                
                startSentenceRecording().catch(err => {
                    console.error('Error auto-starting recording:', err);
                    // ÏûêÎèô ÏãúÏûë Ïã§Ìå® Ïãú Î≤ÑÌäº ÌëúÏãú
                    document.getElementById('start-mic-btn').classList.remove('hidden');
                    document.getElementById('stop-mic-btn').classList.add('hidden');
                    document.getElementById('recording-status').classList.add('hidden');
                });
                
            } else {
                // All sentences complete
                console.log('‚úÖ All sentences recorded!');
                console.log('Total recordings:', sentenceRecordings.length);
                console.log('Recordings:', sentenceRecordings.map((b, i) => `[${i}]: ${b ? b.size + ' bytes' : 'undefined'}`));
                
                // üéØ ÎßàÏßÄÎßâ Î¨∏Ïû• ÏôÑÎ£å - Î≤ÑÌäºÎßå Î≥¥Ïù¥Í≥† ÏÇ¨Ïö©Ïûê ÌÅ¥Î¶≠ ÎåÄÍ∏∞
                document.getElementById('stop-mic-btn').classList.add('hidden');
                document.getElementById('recording-status').classList.add('hidden');
                document.getElementById('evaluate-btn').classList.remove('hidden');
                
                // Stop microphone stream
                if (microphoneStream) {
                    microphoneStream.getTracks().forEach(track => track.stop());
                    microphoneStream = null;
                    console.log('üé§ Microphone released');
                }
            }
        }
        
        // Add completed sentence to the list (disabled - UI removed)
        function addCompletedSentence(index) {
            // UI for completed sentences was removed for cleaner interface
            console.log(`Sentence ${index + 1} completed`);
        }
        
        // Evaluate with Google Cloud STT for accurate scoring
        document.getElementById('evaluate-btn').addEventListener('click', async function() {
            console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            console.log('üìä EVALUATE BUTTON CLICKED');
            console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            console.log('Sentence recordings array:', sentenceRecordings);
            console.log('Number of recordings:', sentenceRecordings.length);
            console.log('Current sentence index:', currentRecordingSentenceIndex);
            console.log('Total sentences:', recordingSentences.length);
            
            const apiKey = document.getElementById('google-api-key').value.trim();
            
            if (!apiKey) {
                alert('‚ö†Ô∏è Google Cloud API key is required for accurate evaluation.\n\nPlease enter your API key in Step 1.');
                return;
            }
            
            // Check if we have any valid recordings
            const validRecordings = sentenceRecordings.filter(blob => blob && blob instanceof Blob);
            console.log('Valid recordings:', validRecordings.length);
            
            if (validRecordings.length === 0) {
                alert('‚ö†Ô∏è No valid recordings found. Please record at least one sentence.');
                return;
            }
            
            // üîß ÌèâÍ∞Ä ÏãúÏûë - Î™®Îì† Î≤ÑÌäº Ïà®ÍπÄ
            document.getElementById('evaluate-btn').classList.add('hidden');
            document.getElementById('stop-mic-btn').classList.add('hidden');
            document.getElementById('start-mic-btn').classList.add('hidden');
            document.getElementById('recording-status').classList.add('hidden');
            
            // Current sentence ÏòÅÏó≠ÎèÑ Ï≤òÎ¶¨ Ï§ë Î©îÏãúÏßÄÎ°ú Î≥ÄÍ≤Ω
            const currentSentenceEl = document.getElementById('current-recording-sentence');
            if (currentSentenceEl) {
                currentSentenceEl.innerHTML = '<span style="color: var(--duo-blue); font-weight: 700;">‚úÖ All recordings complete! Analyzing...</span>';
            }
            
            console.log('‚úÖ All buttons hidden - starting evaluation');
            
            // Show processing status
            const transcriptionEl = document.getElementById('transcription');
            transcriptionEl.style.display = 'block';
            transcriptionEl.innerHTML = '<div style="text-align: center; padding: 20px;"><div style="color: var(--duo-blue); font-size: 18px; font-weight: 700;">‚è≥ Processing with Google Cloud...</div><div style="color: var(--text-gray); font-size: 14px; margin-top: 8px;">Please wait...</div></div>';
            
            try {
                let fullTranscription = '';
                
                // üéØ Í∞Å Î¨∏Ïû•ÏùÑ Í∞úÎ≥ÑÎ°ú Ï≤òÎ¶¨ (60Ï¥à Ï†úÌïú Ïö∞Ìöå!)
                for (let i = 0; i < sentenceRecordings.length; i++) {
                    const blob = sentenceRecordings[i];
                    if (!blob || !(blob instanceof Blob) || blob.size === 0) {
                        console.log(`Skipping sentence ${i + 1} - no recording`);
                        continue;
                    }
                    
                    console.log(`Processing sentence ${i + 1}/${sentenceRecordings.length}, size: ${blob.size} bytes`);
                    transcriptionEl.innerHTML = `
                        <div style="text-align: center; padding: 20px;">
                            <div style="color: var(--duo-blue); font-size: 18px; font-weight: 700; margin-bottom: 8px;">
                                ‚è≥ Processing Sentence ${i + 1} of ${sentenceRecordings.length}
                            </div>
                            <div style="color: var(--text-gray); font-size: 14px;">
                                Please wait...
                            </div>
                        </div>
                    `;
                    
                    try {
                        // Convert to base64
                        const base64Audio = await new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onloadend = () => resolve(reader.result.split(',')[1]);
                            reader.onerror = reject;
                            reader.readAsDataURL(blob);
                        });
                        
                        // Call Google Cloud Speech-to-Text API for this sentence
                        const response = await fetch(
                            `https://speech.googleapis.com/v1/speech:recognize?key=${apiKey}`,
                            {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({
                                    config: {
                                        encoding: 'WEBM_OPUS',
                                        sampleRateHertz: 48000,
                                        languageCode: 'en-US',
                                        enableAutomaticPunctuation: true,
                                        model: 'default',
                                        useEnhanced: true
                                    },
                                    audio: {
                                        content: base64Audio
                                    }
                                })
                            }
                        );
                        
                        if (!response.ok) {
                            const errorData = await response.json().catch(() => ({}));
                            console.error(`Error processing sentence ${i + 1}:`, errorData);
                            // Ïù¥ Î¨∏Ïû•ÏùÄ Ïä§ÌÇµÌïòÍ≥† Í≥ÑÏÜç
                            continue;
                        }
                        
                        const data = await response.json();
                        
                        if (data.results && data.results.length > 0) {
                            const sentenceTranscription = data.results
                                .map(result => result.alternatives[0].transcript)
                                .join(' ');
                            
                            fullTranscription += sentenceTranscription + ' ';
                            console.log(`Sentence ${i + 1} transcription:`, sentenceTranscription);
                        } else {
                            console.log(`No speech detected in sentence ${i + 1}`);
                        }
                        
                    } catch (sentenceError) {
                        console.error(`Error processing sentence ${i + 1}:`, sentenceError);
                        // Ïù¥ Î¨∏Ïû•ÏùÄ Ïä§ÌÇµÌïòÍ≥† Í≥ÑÏÜç
                        continue;
                    }
                }
                
                // Î™®Îì† Î¨∏Ïû• Ï≤òÎ¶¨ ÏôÑÎ£å
                transcription = fullTranscription.trim();
                console.log('Full transcription:', transcription);
                
                if (transcription) {
                    transcriptionEl.innerHTML = `<span style="color: #10B981; font-weight: 600;">‚úÖ Google Cloud Result:</span><br><br>${transcription}`;
                    
                    // Now evaluate with accurate transcription
                    evaluateBasic();
                } else {
                    transcriptionEl.innerHTML = '<span style="color: #EF4444;">‚ö†Ô∏è No speech detected in any sentence.</span>';
                }
                
            } catch (error) {
                console.error('Google Cloud STT error:', error);
                
                let errorMsg = '‚ùå Error: ';
                if (error.message.includes('quota')) {
                    errorMsg += 'API quota exceeded. Check your Google Cloud console.';
                } else if (error.message.includes('API key')) {
                    errorMsg += 'Invalid API key. Please check your key in Step 1.';
                } else if (error.message.includes('403')) {
                    errorMsg += 'Speech-to-Text API not enabled. Enable it at: https://console.cloud.google.com/apis/library/speech.googleapis.com';
                } else {
                    errorMsg += error.message;
                }
                
                transcriptionEl.innerHTML = `<span style="color: #EF4444; font-size: 16px; font-weight: 600;">${errorMsg}</span>`;
                
                // üîß ÏóêÎü¨ Î∞úÏÉù Ïãú Î≤ÑÌäº Î≥µÍµ¨
                document.getElementById('evaluate-btn').classList.remove('hidden');
                console.log('‚ö†Ô∏è Error occurred - evaluate button restored');
            }
        });
        
        // Combine multiple audio blobs into one
        async function combineAudioBlobs(blobs) {
            console.log('Combining audio blobs...');
            console.log('Total blobs:', blobs.length);
            console.log('Blobs array:', blobs);
            
            // Filter out undefined or null blobs
            const validBlobs = blobs.filter(blob => blob && blob instanceof Blob);
            console.log('Valid blobs:', validBlobs.length);
            
            if (validBlobs.length === 0) {
                throw new Error('No valid audio recordings found. Please record at least one sentence.');
            }
            
            // For WebM audio, we can simply concatenate the blobs
            const audioChunks = [];
            
            for (let i = 0; i < validBlobs.length; i++) {
                const blob = validBlobs[i];
                console.log(`Processing blob ${i + 1}/${validBlobs.length}, size: ${blob.size} bytes`);
                
                try {
                    const arrayBuffer = await blob.arrayBuffer();
                    audioChunks.push(new Uint8Array(arrayBuffer));
                } catch (error) {
                    console.error(`Error processing blob ${i + 1}:`, error);
                    throw new Error(`Failed to process recording ${i + 1}`);
                }
            }
            
            console.log('All blobs processed, combining...');
            
            // Calculate total size
            const totalSize = audioChunks.reduce((sum, chunk) => sum + chunk.length, 0);
            console.log('Total combined size:', totalSize, 'bytes');
            
            // Combine into single array
            const combined = new Uint8Array(totalSize);
            let offset = 0;
            for (const chunk of audioChunks) {
                combined.set(chunk, offset);
                offset += chunk.length;
            }
            
            console.log('Audio combination complete');
            return new Blob([combined], { type: 'audio/webm' });
        }
        
        // Real-time highlight function
        function highlightSpokenWordsRealtime(spokenText) {
            const spokenWords = spokenText.toLowerCase().match(/\b\w+\b/g) || [];
            const wordSpans = document.querySelectorAll('#record-text-highlighted .word');
            
            let spokenIndex = 0;
            wordSpans.forEach((span) => {
                const word = span.textContent.toLowerCase().replace(/[^\w]/g, '');
                
                if (!word) return;
                
                if (spokenIndex < spokenWords.length) {
                    const currentSpokenWord = spokenWords[spokenIndex];
                    
                    // If words match, highlight in green
                    if (word === currentSpokenWord || word.includes(currentSpokenWord) || currentSpokenWord.includes(word)) {
                        span.style.backgroundColor = '#D1FAE5';
                        span.style.color = '#065F46';
                        span.style.fontWeight = 'bold';
                        spokenIndex++;
                    } else {
                        // Not yet spoken - keep default
                        span.style.backgroundColor = '';
                        span.style.color = '';
                        span.style.fontWeight = '';
                    }
                } else {
                    // No more spoken words yet
                    span.style.backgroundColor = '';
                    span.style.color = '';
                    span.style.fontWeight = '';
                }
            });
        }
        
        // Save Google settings when changed
        document.getElementById('google-api-key').addEventListener('change', saveGoogleSettings);
        document.getElementById('google-api-key').addEventListener('blur', saveGoogleSettings);
        
        // Highlight spoken words in the original text
        function highlightSpokenWords(spokenText) {
            const originalWords = readingText.toLowerCase().match(/\b\w+\b/g) || [];
            const spokenWords = spokenText.toLowerCase().match(/\b\w+\b/g) || [];
            
            // Create a set of spoken words for quick lookup
            const spokenWordSet = new Set(spokenWords);
            
            // Get all word spans
            const wordSpans = document.querySelectorAll('#record-text-highlighted .word');
            
            // Simple word matching approach
            let spokenIndex = 0;
            wordSpans.forEach((span, index) => {
                const word = span.textContent.toLowerCase().replace(/[^\w]/g, '');
                
                if (!word) return;
                
                // Check if this word was spoken
                if (spokenIndex < spokenWords.length) {
                    const currentSpokenWord = spokenWords[spokenIndex];
                    
                    // If words match, highlight in green
                    if (word === currentSpokenWord || word.includes(currentSpokenWord) || currentSpokenWord.includes(word)) {
                        span.style.backgroundColor = '#D1FAE5';
                        span.style.color = '#065F46';
                        span.style.fontWeight = 'bold';
                        spokenIndex++;
                    } else {
                        // Check if the word appears anywhere in spoken text
                        if (spokenWordSet.has(word)) {
                            span.style.backgroundColor = '#FEF08A';
                            span.style.color = '#854D0E';
                        } else {
                            // Not spoken - gray it out
                            span.style.color = '#D1D5DB';
                            span.style.fontWeight = 'normal';
                        }
                    }
                } else {
                    // No more spoken words - gray out remaining
                    span.style.color = '#D1D5DB';
                    span.style.fontWeight = 'normal';
                }
            });
            
            // Show the legend
        }

        // Evaluation with word matching
        
        function evaluateBasic() {
            const sentences = readingText.match(/[^.!?]+[.!?]+/g) || [readingText];
            const spokenText = transcription.toLowerCase();
            const spokenWords = spokenText.replace(/[^\w\s]/g, '').split(/\s+/).filter(w => w.length > 0);
            
            let totalWords = 0;
            let totalMatched = 0;
            const sentenceResults = [];
            
            sentences.forEach((sentence, index) => {
                const sentenceWords = sentence.trim().split(/\s+/);
                const cleanWords = sentenceWords.map(w => w.toLowerCase().replace(/[^\w]/g, ''));
                
                // Í∞Å Îã®Ïñ¥Ïùò ÏÉÅÌÉúÎ•º Ï∂îÏ†Å
                const wordStates = [];
                const usedSpokenIndices = new Set();
                
                cleanWords.forEach((cleanWord, wordIndex) => {
                    let matched = false;
                    
                    // ÎßêÌïú Îã®Ïñ¥ Ï§ëÏóêÏÑú Îß§Ïπ≠ Ï∞æÍ∏∞
                    for (let i = 0; i < spokenWords.length; i++) {
                        if (usedSpokenIndices.has(i)) continue;
                        
                        if (cleanWord === spokenWords[i] || 
                            cleanWord.includes(spokenWords[i]) || 
                            spokenWords[i].includes(cleanWord)) {
                            matched = true;
                            usedSpokenIndices.add(i);
                            totalMatched++;
                            break;
                        }
                    }
                    
                    wordStates.push({
                        original: sentenceWords[wordIndex],
                        matched: matched
                    });
                });
                
                const matchedInSentence = wordStates.filter(w => w.matched).length;
                totalWords += cleanWords.length;
                const sentenceAccuracy = cleanWords.length > 0 ? Math.round((matchedInSentence / cleanWords.length) * 100) : 0;
                
                sentenceResults.push({
                    text: sentence.trim(),
                    accuracy: sentenceAccuracy,
                    matched: matchedInSentence,
                    total: cleanWords.length,
                    wordStates: wordStates // Í∞Å Îã®Ïñ¥ ÏÉÅÌÉú Ï∂îÍ∞Ä
                });
            });
            
            const overallAccuracy = totalWords > 0 ? Math.round((totalMatched / totalWords) * 100) : 0;
            
            let feedback = '';
            let color = '';
            if (overallAccuracy >= 90) {
                feedback = "Excellent! Your pronunciation is very clear and accurate.";
                color = 'green';
            } else if (overallAccuracy >= 75) {
                feedback = "Great job! Your pronunciation is good with minor improvements needed.";
                color = 'green';
            } else if (overallAccuracy >= 60) {
                feedback = "Good effort! Keep practicing to improve clarity on some sentences.";
                color = 'yellow';
            } else {
                feedback = "Keep practicing! Focus on speaking clearly and at a steady pace.";
                color = 'red';
            }
            
            displayResults(overallAccuracy, totalWords, totalMatched, sentenceResults, feedback, color);
        }
        
        function displayResults(accuracy, totalWords, matchedWords, sentenceResults, feedback, color) {
            // üíæ Store result data for saving
            lastResultData = {
                text: readingText,
                totalScore: accuracy,
                totalWords: totalWords,
                correctWords: matchedWords,
                sentences: sentenceResults.map((result, index) => ({
                    text: result.text,
                    score: result.accuracy,
                    totalWords: result.total,
                    correctWords: result.matched,
                    audioBlob: sentenceRecordings[index] || null,
                    transcription: sentenceTranscriptions[index] || ''
                }))
            };
            
            // Reset save button
            const saveBtn = document.getElementById('save-result-btn');
            if (saveBtn) {
                saveBtn.textContent = 'üíæ Save This Result';
                saveBtn.disabled = false;
            }
            
            // Ï†êÏàò ÌëúÏãú
            document.getElementById('accuracy-score').textContent = accuracy + '%';
            document.getElementById('total-words').textContent = totalWords;
            document.getElementById('matched-words').textContent = matchedWords;
            
            // ÏßÑÌñâ Ïõê Ïï†ÎãàÎ©îÏù¥ÏÖò (Î∞òÏßÄÎ¶Ñ 100 Í∏∞Ï§Ä)
            const progressCircle = document.getElementById('progress-circle');
            const circumference = 2 * Math.PI * 100;
            const offset = circumference * (1 - accuracy / 100);
            progressCircle.setAttribute('stroke-dashoffset', offset);
            
            // Î¨∏Ïû•Î≥Ñ Í≤∞Í≥º ÌëúÏãú (Ïã¨Ìîå Duolingo Ïä§ÌÉÄÏùº)
            const wordAnalysis = document.getElementById('word-analysis');
            wordAnalysis.innerHTML = '';
            
            sentenceResults.forEach((result, index) => {
                const sentenceCard = document.createElement('div');
                
                // Ïπ¥Îìú Ïä§ÌÉÄÏùº (Ïã¨ÌîåÌïú Îã®ÏÉâ)
                let borderColor, scoreColor;
                if (result.accuracy >= 80) {
                    borderColor = '#BBF7D0';
                    scoreColor = 'var(--duo-green)';
                } else if (result.accuracy >= 60) {
                    borderColor = '#FDE68A';
                    scoreColor = '#F59E0B';
                } else {
                    borderColor = '#FECACA';
                    scoreColor = '#EF4444';
                }
                
                sentenceCard.style.cssText = `
                    background: white;
                    border: 3px solid ${borderColor};
                    border-radius: 12px;
                    padding: 16px 20px;
                    margin-bottom: 12px;
                `;
                
                // Ìó§Îçî (Î¨∏Ïû• Î≤àÌò∏ + Ï†êÏàò)
                const header = document.createElement('div');
                header.style.cssText = `
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    margin-bottom: 16px;
                `;
                
                const sentenceLabel = document.createElement('span');
                sentenceLabel.style.cssText = `
                    font-size: 13px;
                    font-weight: 800;
                    color: var(--text-gray);
                    text-transform: uppercase;
                    letter-spacing: 0.5px;
                `;
                sentenceLabel.textContent = `SENTENCE ${index + 1}`;
                
                const scoreSpan = document.createElement('span');
                scoreSpan.style.cssText = `
                    font-size: 22px;
                    font-weight: 900;
                    color: ${scoreColor};
                `;
                scoreSpan.textContent = `${result.accuracy}%`;
                
                header.appendChild(sentenceLabel);
                header.appendChild(scoreSpan);
                
                // Î¨∏Ïû• ÌÖçÏä§Ìä∏ (Îã®Ïñ¥Î≥Ñ ÏÉâÏÉÅ, Í∞ÑÍ≤© Ï¶ùÍ∞Ä)
                const sentenceText = document.createElement('div');
                sentenceText.style.cssText = `
                    line-height: 2.5;
                    font-size: 16px;
                    margin-bottom: 16px;
                    font-weight: 600;
                `;
                
                if (result.wordStates && result.wordStates.length > 0) {
                    result.wordStates.forEach((wordState, wordIndex) => {
                        const wordSpan = document.createElement('span');
                        wordSpan.textContent = wordState.original;
                        wordSpan.style.cssText = `
                            padding: 6px 10px;
                            border-radius: 8px;
                            margin-right: 8px;
                            margin-bottom: 8px;
                            display: inline-block;
                        `;
                        
                        if (wordState.matched) {
                            // Ïò¨Î∞îÎ•∏ Î∞úÏùå - Ï¥àÎ°ù
                            wordSpan.style.backgroundColor = '#D1FAE5';
                            wordSpan.style.color = '#065F46';
                        } else {
                            // ÌãÄÎ¶∞ Î∞úÏùå - Îπ®Í∞ï
                            wordSpan.style.backgroundColor = '#FEE2E2';
                            wordSpan.style.color = '#991B1B';
                            wordSpan.style.textDecoration = 'underline wavy';
                        }
                        
                        sentenceText.appendChild(wordSpan);
                    });
                } else {
                    sentenceText.textContent = result.text;
                    sentenceText.style.color = 'var(--text-dark)';
                }
                
                // ÌÜµÍ≥Ñ
                const stats = document.createElement('div');
                stats.style.cssText = `
                    display: flex;
                    gap: 16px;
                    align-items: center;
                    font-size: 13px;
                    font-weight: 700;
                    padding: 12px 0 8px 0;
                    border-top: 2px solid #F3F4F6;
                `;
                stats.innerHTML = `
                    <span style="color: #059669;">‚úì ${result.matched}</span>
                    <span style="color: #DC2626;">‚úó ${result.total - result.matched}</span>
                    <span style="color: #9CA3AF;">Total ${result.total}</span>
                `;
                
                // ÎÖπÏùå Ïû¨ÏÉù
                const audioContainer = document.createElement('div');
                audioContainer.style.cssText = 'margin-top: 8px;';
                
                if (sentenceRecordings[index] && sentenceRecordings[index] instanceof Blob) {
                    const audioBlob = sentenceRecordings[index];
                    const audioUrl = URL.createObjectURL(audioBlob);
                    
                    const audioLabel = document.createElement('div');
                    audioLabel.style.cssText = `
                        font-size: 12px;
                        font-weight: 700;
                        color: var(--text-gray);
                        margin-bottom: 6px;
                    `;
                    audioLabel.textContent = 'üîä Your Recording';
                    
                    const audioPlayer = document.createElement('audio');
                    audioPlayer.controls = true;
                    audioPlayer.style.cssText = 'width: 100%; height: 32px;';
                    audioPlayer.src = audioUrl;
                    
                    audioContainer.appendChild(audioLabel);
                    audioContainer.appendChild(audioPlayer);
                }
                
                // üé§ Re-record Î≤ÑÌäº Ï∂îÍ∞Ä
                const rerecordBtn = document.createElement('button');
                rerecordBtn.className = 'btn-primary';
                rerecordBtn.style.cssText = `
                    width: 100%;
                    margin-top: 12px;
                    padding: 12px;
                    font-size: 14px;
                    font-weight: 700;
                `;
                rerecordBtn.innerHTML = 'üé§ Re-record This Sentence';
                rerecordBtn.addEventListener('click', () => {
                    openRerecordModal(index, result.text);
                });
                
                sentenceCard.appendChild(header);
                sentenceCard.appendChild(sentenceText);
                sentenceCard.appendChild(stats);
                sentenceCard.appendChild(audioContainer);
                sentenceCard.appendChild(rerecordBtn);
                
                wordAnalysis.appendChild(sentenceCard);
            });
            
            updateProgress(4);
        }

        document.getElementById('reset-btn').addEventListener('click', function() {
            console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            console.log('üîÑ RESET BUTTON CLICKED');
            console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
            
            readingText = '';
            transcription = '';
            realtimeTranscription = '';
            audioChunks = [];
            recordedAudioBlob = null;
            uploadedImages = []; // Clear uploaded images
            
            // Reset sentence recording
            recordingSentences = [];
            currentRecordingSentenceIndex = 0;
            sentenceRecordings = [];
            sentenceTranscriptions = [];
            
            // Stop and cleanup microphone stream
            if (microphoneStream) {
                microphoneStream.getTracks().forEach(track => track.stop());
                microphoneStream = null;
                console.log('Microphone stream stopped and cleaned up');
            }
            
            // Clear timer
            if (recordingTimer) {
                clearInterval(recordingTimer);
                recordingTimer = null;
            }
            
            document.getElementById('reading-text').value = '';
            document.getElementById('transcription').innerHTML = 'Click "Start Recording" to begin...';
            document.getElementById('evaluate-btn').classList.add('hidden');
            document.getElementById('images-container').style.display = 'none';
            document.getElementById('image-previews').innerHTML = '';
            document.getElementById('image-name').textContent = '';
            document.getElementById('image-upload').value = '';
            const completedContainer2 = document.getElementById('completed-sentences-container');
            if (completedContainer2) completedContainer2.style.display = 'none';
            const completedList2 = document.getElementById('completed-sentences-list');
            if (completedList2) completedList2.innerHTML = '';
            
            stopAudio();
            if (recognition) {
                recognition.stop();
                recognition = null;
            }
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
            }
            
            // Reset all highlights and hide legend
            document.querySelectorAll('.sentence').forEach(span => {
                span.style.backgroundColor = '';
                span.style.color = '';
                span.style.fontWeight = '';
            });
            document.querySelectorAll('.sentence-word').forEach(span => {
                span.style.backgroundColor = '';
                span.style.color = '';
                span.style.fontWeight = '';
            });
            
            updateProgress(1);
        });
        
        // ========================================
        // üíæ UI Functions for History
        // ========================================
        
        // Load and display past texts
        async function loadPastTexts() {
            console.log('üìù Loading past texts...');
            try {
                if (!db) {
                    console.warn('‚ö†Ô∏è Database not ready');
                    return;
                }
                
                const texts = await getRecentTexts(5);
                console.log('üìù Found', texts.length, 'past texts');
                
                const pastTextsSection = document.getElementById('past-texts-section');
                const pastTextsList = document.getElementById('past-texts-list');
                
                if (!pastTextsSection || !pastTextsList) {
                    console.error('‚ùå Past texts elements not found');
                    return;
                }
                
                if (texts.length === 0) {
                    console.log('üìù No past texts to display');
                    pastTextsSection.style.display = 'none';
                    return;
                }
                
                pastTextsSection.style.display = 'block';
                pastTextsList.innerHTML = '';
                console.log('üìù Rendering', texts.length, 'text cards...');
                
                texts.forEach(textData => {
                    const textCard = document.createElement('div');
                    textCard.style.cssText = `
                        position: relative;
                        padding: 12px;
                        padding-right: 44px;
                        background: white;
                        border: 2px solid #E5E7EB;
                        border-radius: 8px;
                        margin-bottom: 8px;
                        cursor: default;
                        transition: all 0.2s;
                    `;
                    
                    const preview = textData.text.length > 60 ? textData.text.substring(0, 60) + '...' : textData.text;
                    const date = new Date(textData.lastUsedAt).toLocaleDateString();
                    
                    // Content wrapper
                    const contentDiv = document.createElement('div');
                    contentDiv.style.cursor = 'pointer';
                    contentDiv.innerHTML = `
                        <div style="font-size: 14px; font-weight: 600; color: var(--text-dark); margin-bottom: 4px;">${preview}</div>
                        <div style="font-size: 12px; color: var(--text-gray);">Used ${textData.usedCount} time${textData.usedCount > 1 ? 's' : ''} ‚Ä¢ ${date}</div>
                    `;
                    
                    // Delete button
                    const deleteBtn = document.createElement('button');
                    deleteBtn.innerHTML = 'üóëÔ∏è';
                    deleteBtn.style.cssText = `
                        position: absolute;
                        top: 8px;
                        right: 8px;
                        background: none;
                        border: none;
                        font-size: 18px;
                        cursor: pointer;
                        padding: 4px 8px;
                        border-radius: 6px;
                        transition: all 0.2s;
                        opacity: 0.5;
                        z-index: 10;
                    `;
                    
                    deleteBtn.addEventListener('mouseover', function() {
                        this.style.opacity = '1';
                        this.style.backgroundColor = '#FEE2E2';
                        this.style.transform = 'scale(1.1)';
                    });
                    deleteBtn.addEventListener('mouseout', function() {
                        this.style.opacity = '0.5';
                        this.style.backgroundColor = 'transparent';
                        this.style.transform = 'scale(1)';
                    });
                    
                    deleteBtn.addEventListener('click', async function(e) {
                        e.stopPropagation(); // Ïπ¥Îìú ÌÅ¥Î¶≠ Î∞©ÏßÄ
                        e.preventDefault(); // Í∏∞Î≥∏ ÎèôÏûë Î∞©ÏßÄ
                        console.log('üóëÔ∏è Delete button clicked for:', textData.id);
                        
                        const confirmDelete = confirm('Are you sure you want to delete this text?\n\n' + preview);
                        console.log('Confirm result:', confirmDelete);
                        
                        if (confirmDelete) {
                            console.log('Starting deletion...');
                            try {
                                if (!db) {
                                    throw new Error('Database not initialized');
                                }
                                
                                await deleteText(textData.id);
                                console.log('‚úÖ Text deleted successfully');
                                
                                // Animate removal
                                textCard.style.opacity = '0';
                                textCard.style.transform = 'translateX(-20px)';
                                
                                setTimeout(() => {
                                    console.log('Refreshing past texts...');
                                    loadPastTexts(); // ÏÉàÎ°úÍ≥†Ïπ®
                                }, 300);
                            } catch (error) {
                                console.error('‚ùå Failed to delete text:', error);
                                alert('‚ö†Ô∏è Failed to delete text: ' + error.message);
                            }
                        } else {
                            console.log('Deletion cancelled by user');
                        }
                    });
                    
                    // Card hover effects
                    textCard.addEventListener('mouseover', function() {
                        this.style.borderColor = 'var(--duo-blue)';
                        this.style.backgroundColor = '#F0F9FF';
                    });
                    textCard.addEventListener('mouseout', function() {
                        this.style.borderColor = '#E5E7EB';
                        this.style.backgroundColor = 'white';
                    });
                    
                    // Content click to load text (not the delete button)
                    contentDiv.addEventListener('click', function() {
                        console.log('üìÑ Text card clicked, loading text...');
                        document.getElementById('reading-text').value = textData.text;
                        textCard.style.borderColor = 'var(--duo-green)';
                        setTimeout(() => {
                            textCard.style.borderColor = '#E5E7EB';
                        }, 1000);
                    });
                    
                    textCard.appendChild(contentDiv);
                    textCard.appendChild(deleteBtn);
                    pastTextsList.appendChild(textCard);
                });
            } catch (error) {
                console.error('Failed to load past texts:', error);
            }
        }
        
        // Save current result
        let lastResultData = null;
        
        async function saveCurrentResult() {
            if (!lastResultData) {
                alert('‚ö†Ô∏è No result to save!');
                return;
            }
            
            try {
                await savePracticeResult(lastResultData);
                alert('‚úÖ Result saved successfully!');
                document.getElementById('save-result-btn').textContent = '‚úì Saved';
                document.getElementById('save-result-btn').disabled = true;
            } catch (error) {
                console.error('Failed to save result:', error);
                alert('‚ö†Ô∏è Failed to save result. Please try again.');
            }
        }
        
        // Load and display history
        async function loadHistory(filter = 'all') {
            try {
                let results = await getAllResults(50);
                
                // Apply filter
                const now = new Date();
                const sevenDaysAgo = new Date(now - 7 * 24 * 60 * 60 * 1000);
                
                if (filter === 'recent') {
                    results = results.filter(r => new Date(r.practiceDate) > sevenDaysAgo);
                } else if (filter === 'high') {
                    results = results.filter(r => r.totalScore >= 80);
                } else if (filter === 'low') {
                    results = results.filter(r => r.totalScore < 80);
                }
                
                const historyList = document.getElementById('history-list');
                historyList.innerHTML = '';
                
                if (results.length === 0) {
                    historyList.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-gray);">No practice history yet. Complete a practice session to see results here!</div>';
                    return;
                }
                
                results.forEach(result => {
                    const resultCard = document.createElement('div');
                    const date = new Date(result.practiceDate);
                    const dateStr = date.toLocaleString();
                    const textPreview = result.text.length > 80 ? result.text.substring(0, 80) + '...' : result.text;
                    
                    let scoreColor;
                    if (result.totalScore >= 90) scoreColor = 'var(--duo-green)';
                    else if (result.totalScore >= 70) scoreColor = '#F59E0B';
                    else scoreColor = '#EF4444';
                    
                    resultCard.style.cssText = `
                        background: white;
                        border: 3px solid #E5E7EB;
                        border-radius: 12px;
                        padding: 20px;
                        margin-bottom: 16px;
                    `;
                    
                    resultCard.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                            <div style="font-size: 13px; font-weight: 700; color: var(--text-gray);">üìÖ ${dateStr}</div>
                            <div style="font-size: 24px; font-weight: 900; color: ${scoreColor};">${result.totalScore}%</div>
                        </div>
                        <div style="font-size: 15px; color: var(--text-dark); margin-bottom: 12px; line-height: 1.6;">"${textPreview}"</div>
                        <div style="font-size: 13px; color: var(--text-gray); margin-bottom: 12px;">
                            <span style="color: var(--duo-green); font-weight: 700;">‚úì ${result.correctWords}</span> / 
                            <span style="font-weight: 700;">${result.totalWords} words</span>
                        </div>
                        <div style="display: flex; gap: 8px;" id="result-${result.id}-buttons">
                            <button class="btn-gray" style="flex: 1; padding: 10px; font-size: 13px;" onclick="showResultDetail('${result.id}')">üìä Details</button>
                            <button class="btn-danger" style="padding: 10px 16px; font-size: 13px;" onclick="deleteResultConfirm('${result.id}')">üóëÔ∏è</button>
                        </div>
                        <div id="result-${result.id}-detail" style="display: none; margin-top: 16px; padding-top: 16px; border-top: 2px solid #E5E7EB;"></div>
                    `;
                    
                    historyList.appendChild(resultCard);
                });
                
            } catch (error) {
                console.error('Failed to load history:', error);
                document.getElementById('history-list').innerHTML = '<div style="text-align: center; padding: 40px; color: #EF4444;">Failed to load history. Please refresh.</div>';
            }
        }
        
        // Show result detail
        window.showResultDetail = async function(resultId) {
            const detailDiv = document.getElementById(`result-${resultId}-detail`);
            if (detailDiv.style.display === 'block') {
                detailDiv.style.display = 'none';
                return;
            }
            
            try {
                const transaction = db.transaction(['practiceResults'], 'readonly');
                const store = transaction.objectStore('practiceResults');
                const request = store.get(resultId);
                
                request.onsuccess = () => {
                    const result = request.result;
                    if (!result) return;
                    
                    let html = '<h4 style="font-size: 16px; font-weight: 800; margin-bottom: 12px;">Sentence Details:</h4>';
                    
                    result.sentences.forEach((sent, idx) => {
                        let scoreColor;
                        if (sent.score >= 80) scoreColor = 'var(--duo-green)';
                        else if (sent.score >= 60) scoreColor = '#F59E0B';
                        else scoreColor = '#EF4444';
                        
                        html += `
                            <div style="background: #F9FAFB; padding: 12px; border-radius: 8px; margin-bottom: 8px;">
                                <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                                    <span style="font-size: 13px; font-weight: 700; color: var(--text-gray);">Sentence ${idx + 1}</span>
                                    <span style="font-size: 16px; font-weight: 900; color: ${scoreColor};">${sent.score}%</span>
                                </div>
                                <div style="font-size: 14px; color: var(--text-dark); margin-bottom: 8px;">${sent.text}</div>
                                <div style="font-size: 12px; color: var(--text-gray);">
                                    ‚úì ${sent.correctWords} / ${sent.totalWords} words
                                </div>
                            </div>
                        `;
                    });
                    
                    detailDiv.innerHTML = html;
                    detailDiv.style.display = 'block';
                };
            } catch (error) {
                console.error('Failed to show detail:', error);
            }
        };
        
        // Delete result
        window.deleteResultConfirm = async function(resultId) {
            if (!confirm('Are you sure you want to delete this result?')) return;
            
            try {
                await deleteResult(resultId);
                await loadHistory(document.getElementById('history-filter').value);
                alert('‚úÖ Result deleted');
            } catch (error) {
                console.error('Failed to delete result:', error);
                alert('‚ö†Ô∏è Failed to delete result');
            }
        };
        
        // Show history page
        function showHistory() {
            // Hide all steps
            for (let i = 1; i <= 4; i++) {
                document.getElementById(`step${i}-content`).classList.add('hidden');
            }
            document.getElementById('step5-content').classList.remove('hidden');
            loadHistory('all');
        }
        
        // Event Listeners
        // (Past texts are loaded in initializeApp)
        
        // Toggle past texts
        document.getElementById('toggle-past-texts')?.addEventListener('click', function() {
            const list = document.getElementById('past-texts-list');
            if (list.style.display === 'none') {
                list.style.display = 'block';
                this.textContent = 'Hide';
            } else {
                list.style.display = 'none';
                this.textContent = 'Show';
            }
        });
        
        // Save result button
        document.getElementById('save-result-btn')?.addEventListener('click', saveCurrentResult);
        
        // View history button
        document.getElementById('view-history-btn')?.addEventListener('click', showHistory);
        
        // Back from history
        document.getElementById('back-from-history-btn')?.addEventListener('click', () => {
            document.getElementById('step5-content').classList.add('hidden');
            document.getElementById('step4-content').classList.remove('hidden');
        });
        
        // Refresh history
        document.getElementById('refresh-history-btn')?.addEventListener('click', () => {
            loadHistory(document.getElementById('history-filter').value);
        });
        
        // History filter
        document.getElementById('history-filter')?.addEventListener('change', function() {
            loadHistory(this.value);
        });
        
        // ========================================
        // üé§ Re-record Functionality
        // ========================================
        
        let rerecordIndex = -1;
        let rerecordText = '';
        let rerecordMediaRecorder = null;
        let rerecordAudioChunks = [];
        let rerecordStream = null;
        
        // Open re-record modal
        function openRerecordModal(sentenceIndex, sentenceText) {
            rerecordIndex = sentenceIndex;
            rerecordText = sentenceText;
            
            document.getElementById('rerecord-title').textContent = `Re-record Sentence ${sentenceIndex + 1}`;
            document.getElementById('rerecord-sentence-text').textContent = sentenceText;
            document.getElementById('rerecord-status').textContent = 'Ready to record';
            document.getElementById('rerecord-start-btn').style.display = 'block';
            document.getElementById('rerecord-stop-btn').style.display = 'none';
            
            document.getElementById('rerecord-modal').classList.add('active');
        }
        
        // Close modal
        function closeRerecordModal() {
            document.getElementById('rerecord-modal').classList.remove('active');
            
            // Cleanup
            if (rerecordMediaRecorder && rerecordMediaRecorder.state !== 'inactive') {
                rerecordMediaRecorder.stop();
            }
            if (rerecordStream) {
                rerecordStream.getTracks().forEach(track => track.stop());
                rerecordStream = null;
            }
            
            rerecordIndex = -1;
            rerecordText = '';
            rerecordAudioChunks = [];
        }
        
        // Start recording
        document.getElementById('rerecord-start-btn')?.addEventListener('click', async function() {
            try {
                // Request microphone
                rerecordStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true
                    }
                });
                
                rerecordMediaRecorder = new MediaRecorder(rerecordStream, {
                    mimeType: 'audio/webm;codecs=opus'
                });
                
                rerecordAudioChunks = [];
                
                rerecordMediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        rerecordAudioChunks.push(event.data);
                    }
                };
                
                rerecordMediaRecorder.start();
                
                // Update UI
                document.getElementById('rerecord-status').innerHTML = '<span style="color: #EF4444;">üî¥ Recording...</span>';
                document.getElementById('rerecord-start-btn').style.display = 'none';
                document.getElementById('rerecord-stop-btn').style.display = 'block';
                
                console.log('‚úÖ Re-recording started for sentence:', rerecordIndex);
                
            } catch (error) {
                console.error('‚ùå Microphone error:', error);
                alert('‚ö†Ô∏è Microphone access denied. Please allow microphone access.');
            }
        });
        
        // Stop recording and evaluate
        document.getElementById('rerecord-stop-btn')?.addEventListener('click', async function() {
            if (!rerecordMediaRecorder || rerecordMediaRecorder.state === 'inactive') {
                alert('‚ö†Ô∏è No active recording');
                return;
            }
            
            // Stop recording
            rerecordMediaRecorder.stop();
            
            // Update UI
            document.getElementById('rerecord-status').innerHTML = '<span style="color: var(--duo-blue);">‚è≥ Processing...</span>';
            document.getElementById('rerecord-stop-btn').disabled = true;
            
            // Wait for audio data
            await new Promise(resolve => {
                rerecordMediaRecorder.onstop = resolve;
            });
            
            const audioBlob = new Blob(rerecordAudioChunks, { type: 'audio/webm' });
            console.log('‚úÖ Audio recorded:', audioBlob.size, 'bytes');
            
            // Evaluate with Google Cloud STT
            const apiKey = document.getElementById('google-api-key').value.trim();
            if (!apiKey) {
                alert('‚ö†Ô∏è Google Cloud API key is required');
                closeRerecordModal();
                return;
            }
            
            try {
                // Convert to base64
                const base64Audio = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result.split(',')[1]);
                    reader.onerror = reject;
                    reader.readAsDataURL(audioBlob);
                });
                
                // Call Google Cloud STT
                const response = await fetch(
                    `https://speech.googleapis.com/v1/speech:recognize?key=${apiKey}`,
                    {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            config: {
                                encoding: 'WEBM_OPUS',
                                sampleRateHertz: 48000,
                                languageCode: 'en-US',
                                enableAutomaticPunctuation: true
                            },
                            audio: { content: base64Audio }
                        })
                    }
                );
                
                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error(data.error?.message || 'STT API error');
                }
                
                const newTranscription = data.results?.[0]?.alternatives?.[0]?.transcript || '';
                console.log('New transcription:', newTranscription);
                
                // Evaluate accuracy
                const originalWords = rerecordText.toLowerCase().match(/\b\w+\b/g) || [];
                const spokenWords = newTranscription.toLowerCase().match(/\b\w+\b/g) || [];
                
                let matchedCount = 0;
                const wordStates = [];
                
                originalWords.forEach(originalWord => {
                    const matched = spokenWords.includes(originalWord);
                    if (matched) matchedCount++;
                    wordStates.push({
                        original: originalWord,
                        matched: matched
                    });
                });
                
                const newAccuracy = originalWords.length > 0 
                    ? Math.round((matchedCount / originalWords.length) * 100) 
                    : 0;
                
                console.log('New accuracy:', newAccuracy);
                
                // Update global data
                sentenceRecordings[rerecordIndex] = audioBlob;
                sentenceTranscriptions[rerecordIndex] = newTranscription;
                
                // Update lastResultData
                if (lastResultData && lastResultData.sentences[rerecordIndex]) {
                    lastResultData.sentences[rerecordIndex] = {
                        text: rerecordText,
                        score: newAccuracy,
                        totalWords: originalWords.length,
                        correctWords: matchedCount,
                        audioBlob: audioBlob,
                        transcription: newTranscription
                    };
                }
                
                // Recalculate total score
                const allSentences = lastResultData.sentences;
                const totalWords = allSentences.reduce((sum, s) => sum + s.totalWords, 0);
                const totalCorrect = allSentences.reduce((sum, s) => sum + s.correctWords, 0);
                const totalAccuracy = Math.round((totalCorrect / totalWords) * 100);
                
                lastResultData.totalScore = totalAccuracy;
                lastResultData.totalWords = totalWords;
                lastResultData.correctWords = totalCorrect;
                
                // Refresh results display
                const sentenceResults = allSentences.map(s => ({
                    text: s.text,
                    accuracy: s.score,
                    total: s.totalWords,
                    matched: s.correctWords,
                    wordStates: []
                }));
                
                displayResults(totalAccuracy, totalWords, totalCorrect, sentenceResults, '', '');
                
                // Close modal
                alert(`‚úÖ Re-recorded!\n\nNew Score: ${newAccuracy}%\nOverall Score: ${totalAccuracy}%`);
                closeRerecordModal();
                
            } catch (error) {
                console.error('‚ùå Evaluation error:', error);
                alert('‚ö†Ô∏è Evaluation failed: ' + error.message);
                document.getElementById('rerecord-stop-btn').disabled = false;
                document.getElementById('rerecord-status').textContent = 'Error occurred. Try again.';
            }
        });
        
        // Cancel button
        document.getElementById('rerecord-cancel-btn')?.addEventListener('click', closeRerecordModal);
        
        // Close modal on background click
        document.getElementById('rerecord-modal')?.addEventListener('click', function(e) {
            if (e.target === this) {
                closeRerecordModal();
            }
        });
        
    </script>
</body>
</html>
